ÓUINT8_C(x) (x##u) ÔUINT16_C(x) (x##u) ÕUINT32_C(x) (x##u) ÖUINT64_C(x) __ESCAPE__(x##ull) ÙINTMAX_C(x) __ESCAPE__(x##ll) ÚUINTMAX_C(x) __ESCAPE__(x##ull)  @    6     
       C:\Keil4\ARM\RV31\INC\  stdint.h     È       C:\Keil4\ARM\RV31\INC\stdint.h ARM C/C++ Compiler, 4.1 [Build 713]          signed char short int long long unsigned char  unsigned short  unsigned int  unsigned long long Pint8_t Y% Pint16_t h& Pint32_t q' Pint64_t x( Puint8_t … + Puint16_t – , Puint32_t ¨ - Puint64_t ¸ . Pint_least8_t Y4 Pint_least16_t h5 Pint_least32_t q6 Pint_least64_t x7 Puint_least8_t … : Puint_least16_t – ; Puint_least32_t ¨ < Puint_least64_t ¸ = Pint_fast8_t qB Pint_fast16_t qC Pint_fast32_t qD Pint_fast64_t xE Puint_fast8_t ¨ H Puint_fast16_t ¨ I Puint_fast32_t ¨ J Puint_fast64_t ¸ K Pintptr_t qN Puintptr_t ¨ O Pintmax_t xR Puintmax_t ¸ S                  __CORE_CMINSTR_H__  )__NOP __nop 1__WFI __wfi 9__WFE __wfe @__SEV __sev I__ISB() __isb(0xF) Q__DSB() __dsb(0xF) Y__DMB() __dmb(0xF) c__REV __rev “__RBIT __rbit __LDREXB(ptr) ((uint8_t ) __ldrex(ptr)) §__LDREXH(ptr) ((uint16_t) __ldrex(ptr)) ±__LDREXW(ptr) ((uint32_t ) __ldrex(ptr)) ½__STREXB(value,ptr) __strex(value, ptr) É__STREXH(value,ptr) __strex(value, ptr) Õ__STREXW(value,ptr) __strex(value, ptr) à__CLREX __clrex ì__SSAT __ssat ÷__USAT __usat __CLZ __clz  L    A     
       C:\Keil4\ARM\CMSIS\Include\  core_cmInstr.h     d        C:\Keil4\ARM\CMSIS\Include\core_cmInstr.h ARM C/C++ Compiler, 4.1 [Build 713]                           __CORE_CMFUNC_H__  é__enable_fault_irq __enable_fiq ñ__disable_fault_irq __disable_fiq    L    @     
       C:\Keil4\ARM\CMSIS\Include\  core_cmFunc.h     $       C:\Keil4\ARM\CMSIS\Include\core_cmFunc.h ARM C/C++ Compiler, 4.1 [Build 713]          ;£0__get_CONTROL  $  a__result $  Y__regControl $  P <ÜA__set_CONTROL  $$  control Y__regControl $  P ;–R__get_IPSR  $  a__result $  Y__regIPSR $  P ;Ðc__get_APSR  $  a__result $  Y__regAPSR $  P ;Št__get_xPSR  $  a__result $  Y__regXPSR $  P ;Ó…__get_PSP  $  a__result $  Y__regProcessStackPointer $  P <œ–__set_PSP  $$  topOfProcStack Y__regProcessStackPointer $  P ;â§__get_MSP  $  a__result $  Y__regMainStackPointer $  P <¨¸__set_MSP  $$  topOfMainStack Y__regMainStackPointer $  P ;éÉ__get_PRIMASK  $  a__result $  Y__regPriMask $  P <£Ú__set_PRIMASK  $$  priMask Y__regPriMask $  P ;äý__get_BASEPRI  $  a__result $  Y__regBasePri $  P <ž Ž__set_BASEPRI  $$  basePri Y__regBasePri $  P ;ã Ÿ__get_FAULTMASK  $  a__result $  Y__regFaultMask $  P <£°__set_FAULTMASK  $$  faultMask Y__regFaultMask $  P             !   "   #     __CORE_CM3_H_GENERIC  E__CM3_CMSIS_VERSION_MAIN (0x02) F__CM3_CMSIS_VERSION_SUB (0x00) G__CM3_CMSIS_VERSION ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) I__CORTEX_M (0x03) M__ASM __asm N__INLINE __inline ^_`h__CORE_CM3_H_DEPENDANT  n__I volatile const p__O volatile q__IO volatile •SCB_CPUID_IMPLEMENTER_Pos 24 –SCB_CPUID_IMPLEMENTER_Msk (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos) ˜SCB_CPUID_VARIANT_Pos 20 ™SCB_CPUID_VARIANT_Msk (0xFUL << SCB_CPUID_VARIANT_Pos) ›SCB_CPUID_PARTNO_Pos 4 œSCB_CPUID_PARTNO_Msk (0xFFFUL << SCB_CPUID_PARTNO_Pos) žSCB_CPUID_REVISION_Pos 0 ŸSCB_CPUID_REVISION_Msk (0xFUL << SCB_CPUID_REVISION_Pos) ¢SCB_ICSR_NMIPENDSET_Pos 31 £SCB_ICSR_NMIPENDSET_Msk (1UL << SCB_ICSR_NMIPENDSET_Pos) ¥SCB_ICSR_PENDSVSET_Pos 28 ¦SCB_ICSR_PENDSVSET_Msk (1UL << SCB_ICSR_PENDSVSET_Pos) ¨SCB_ICSR_PENDSVCLR_Pos 27 ©SCB_ICSR_PENDSVCLR_Msk (1UL << SCB_ICSR_PENDSVCLR_Pos) «SCB_ICSR_PENDSTSET_Pos 26 ¬SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ 
SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ LPC_CANCR_BASE (LPC_APB0_BASE + 0x40000) ´ LPC_CAN1_BASE (LPC_APB0_BASE + 0x44000) µ LPC_CAN2_BASE (LPC_APB0_BASE + 0x48000) ¶ LPC_I2C1_BASE (LPC_APB0_BASE + 0x5C000) ¹ LPC_SSP0_BASE (LPC_APB1_BASE + 0x08000) º LPC_DAC_BASE (LPC_APB1_BASE + 0x0C000) » LPC_TIM2_BASE (LPC_APB1_BASE + 0x10000) ¼ LPC_TIM3_BASE (LPC_APB1_BASE + 0x14000) ½ LPC_UART2_BASE (LPC_APB1_BASE + 0x18000) ¾ LPC_UART3_BASE (LPC_APB1_BASE + 0x1C000) ¿ LPC_I2C2_BASE (LPC_APB1_BASE + 0x20000) À LPC_I2S_BASE (LPC_APB1_BASE + 0x28000) Á LPC_RIT_BASE (LPC_APB1_BASE + 0x30000) Â LPC_MCPWM_BASE (LPC_APB1_BASE + 0x38000) Ã LPC_QEI_BASE (LPC_APB1_BASE + 0x3C000) Ä LPC_SC_BASE (LPC_APB1_BASE + 0x7C000) Ç LPC_EMAC_BASE (LPC_AHB_BASE + 0x00000) È LPC_GPDMA_BASE (LPC_AHB_BASE + 0x04000) É LPC_GPDMACH0_BASE (LPC_AHB_BASE + 0x04100) Ê LPC_GPDMACH1_BASE (LPC_AHB_BASE + 0x04120) Ë LPC_GPDMACH2_BASE (LPC_AHB_BASE + 0x04140) Ì L

SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ LPC_CANCR_BASE (LPC_APB0_BASE + 0x40000) ´ LPC_CAN1_BASE (LPC_APB0_BASE + 0x44000) µ LPC_CAN2_BASE (LPC_APB0_BASE + 0x48000) ¶ LPC_I2C1_BASE (LPC_APB0_BASE + 0x5C000) ¹ LPC_SSP0_BASE (LPC_APB1_BASE + 0x08000) º LPC_DAC_BASE (LPC_APB1_BASE + 0x0C000) » LPC_TIM2_BASE (LPC_APB1_BASE + 0x10000) ¼ LPC_TIM3_BASE (LPC_APB1_BASE + 0x14000) ½ LPC_UART2_BASE (LPC_APB1_BASE + 0x18000) ¾ LPC_UART3_BASE (LPC_APB1_BASE + 0x1C000) ¿ LPC_I2C2_BASE (LPC_APB1_BASE + 0x20000) À LPC_I2S_BASE (LPC_APB1_BASE + 0x28000) Á LPC_RIT_BASE (LPC_APB1_BASE + 0x30000) Â LPC_MCPWM_BASE (LPC_APB1_BASE + 0x38000) Ã LPC_QEI_BASE (LPC_APB1_BASE + 0x3C000) Ä LPC_SC_BASE (LPC_APB1_BASE + 0x7C000) Ç LPC_EMAC_BASE (LPC_AHB_BASE + 0x00000) È LPC_GPDMA_BASE (LPC_AHB_BASE + 0x04000) É LPC_GPDMACH0_BASE (LPC_AHB_BASE + 0x04100) Ê LPC_GPDMACH1_BASE (LPC_AHB_BASE + 0x04120) Ë LPC_GPDMACH2_BASE (LPC_AHB_BASE + 0x04140) Ì L


Write a program in MPI to print total number of process and rank of each process.

#include<mpi.h>
#include<stdio.h>
int main(int argc,char *argv[]){
  int rank,size;
  MPI_Init(&argc,&argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  MPI_Comm_size(MPI_COMM_WORLD,&size);
  printf("My rank is %d in total %d processes\n",rank,size);
  MPI_Finalize();
return 0;
}

/*mpicc sample.c -o sample.out*/
/*mpirun -np 4 ./sample.out*/

/*
My rank is 0 in total 4 processes
My rank is 1 in total 4 processes
My rank is 3 in total 4 processes
My rank is 2 in total 4 processes
*/


Write a simple MPI program to find out pow (x, rank) for all the processes where 'x' is the integer constant and ‘rank' is the rank of the process.
#include<mpi.h>
#include<stdio.h>
#include<math.h>

int main(int argc,char** argv){
  int rank,size;
  const int s=2;
  MPI_Init(&argc,&argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  MPI_Comm_size(MPI_COMM_WORLD,&size);
  int result=(int)pow(s, rank);
  printf("Process %d: Pow(%d,%d)= %d\n",rank,s,rank,result);
  MPI_Finalize();
  return 0;
}

/*mpicc -o lab1_q1 lab1_q1.c -lm
mpirun -np 4 ./lab1_q1*/

/*
Process 0: Pow(2,0)= 1
Process 1: Pow(2,1)= 2
Process 2: Pow(2,2)= 4
Process 3: Pow(2,3)= 8
*/

Write a program in MPI where even ranked process prints "Hello" and odd ranked prints "World".

#include<mpi.h>
#include<stdio.h>
int main(int argc,char *argv[]){
  int rank;
  MPI_Init(&argc,&argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  if( rank % 2 == 0)
    printf("Hello\n");
  else
    printf("World\n");
  MPI_Finalize();
  return 0;
}

/*mpicc -o lab1_q2 lab1_q2.c -lm
mpirun -np 4 ./lab1_q2

Hello
World
Hello
World
*/


Write a program in MPI to simulate simple calculator. Perform each operation using different process in parallel.
#include <stdio.h>
#include <mpi.h>

void perform_operation(int rank, double a, double b) {
    switch (rank) {
        case 0: printf("Process %d - Addition: %f + %f = %f\n", rank, a, b, a + b); break;
        case 1: printf("Process %d - Subtraction: %f - %f = %f\n", rank, a, b, a - b); break;
        case 2: printf("Process %d - Multiplication: %f * %f = %f\n", rank, a, b, a * b); break;
        case 3: b != 0 ? printf("Process %d - Division: %f / %f = %f\n", rank, a, b, a / b) : printf("Process %d - Division by zero error!\n", rank); break;
    }
}

int main(int argc, char *argv[]) {
    int rank;
    double a, b;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (rank == 0) {
        printf("Enter two numbers: ");
        fflush(stdout);
        scanf("%lf %lf", &a, &b);
    }

    MPI_Bcast(&a, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&b, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);

    if (rank < 4) perform_operation(rank, a, b);

    MPI_Finalize();
    return 0;
}

/*mpicc -o q3 q3.c -lm
mpirun -np 4 ./q3

Enter two numbers: 4 5
Process 0 - Addition: 4.000000 + 5.000000 = 9.000000
Process 1 - Subtraction: 4.000000 - 5.000000 = -1.000000
Process 2 - Multiplication: 4.000000 * 5.000000 = 20.000000
Process 3 - Division: 4.000000 / 5.000000 = 0.800000
*/


Write a program in MPI to toggle the character of a given string indexed by the rank of the process. Hint: Suppose the string is HELLO and there are 5 processes, then process 0 toggle 'H' to 'h', process 1 toggle 'E' to 'e' and so on.

#include <stdio.h>
#include <mpi.h>
#include <ctype.h>

void toggle_case(char *c) {
    if (islower(*c)) *c = toupper(*c);
    else if (isupper(*c)) *c = tolower(*c);
}

int main(int argc, char *argv[]) {
    int rank, length;
    char input[100];

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (rank == 0) {
        printf("Enter a string: ");
        fflush(stdout);
        fgets(input, 100, stdin);

        length = 0;
        while (input[length] != '\0' && input[length] != '\n') length++;

        MPI_Bcast(&length, 1, MPI_INT, 0, MPI_COMM_WORLD);
        MPI_Bcast(input, length, MPI_CHAR, 0, MPI_COMM_WORLD);
    } else {
        MPI_Bcast(&length, 1, MPI_INT, 0, MPI_COMM_WORLD);
        MPI_Bcast(input, length, MPI_CHAR, 0, MPI_COMM_WORLD);
    }

    if (rank < length) toggle_case(&input[rank]);

    MPI_Gather(&input[rank], 1, MPI_CHAR, input, 1, MPI_CHAR, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        input[length] = '\0';
        printf("Modified string: %s\n", input);
    }

    MPI_Finalize();
    return 0;
}

/*mpicc -o q4 q4.c -lm
mpirun -np 4 ./q4
*Enter a string: GOAT
Modified string: goat
*/


Write a program in MPI where even ranked process prints factorial of the rank and odd ranked process prints ranks Fibonacci number.

#include <mpi.h>
#include <stdio.h>

long long factorial(int n) {
    long long result = 1;
    for (int i = 2; i <= n; ++i) result *= i;
    return result;
}

void fibonacci(int n) {
    long long a = 0, b = 1;
    printf("Fibonacci up to %d: ", n);
    for (int i = 0; i <= n; ++i) {
        printf("%lld ", a);
        long long temp = a + b;
        a = b;
        b = temp;
    }
    printf("\n");
}

int main(int argc, char **argv) {
    int rank;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (rank % 2 == 0)
        printf("Process %d: %lld (Factorial)\n", rank, factorial(rank));
    else {
        printf("Process %d: ", rank);
        fibonacci(rank);
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q5 q5.c -lm
mpirun -np 4 ./q5
Process 3: Fibonacci up to 3: 0 1 1 2 
Process 2: 2 (Factorial)
Process 0: 1 (Factorial)
Process 1: Fibonacci up to 1: 0 1 
*/


#Write a program in MPI to reverse the digits of the following integer array of size 9 with 9 processes. Initialize the array to the following values.
Input array: 18, 523, 301, 1234, 2, 14, 108, 150, 1928
Output array: 81, 325, 103, 4321, 2, 41, 801, 51, 8291

#include <stdio.h>
#include <mpi.h>

int reverse_digits(int n) {
    int reversed = 0;
    while (n > 0) {
        reversed = reversed * 10 + (n % 10);
        n /= 10;
    }
    return reversed;
}

int main(int argc, char *argv[]) {
    int rank, size;
    int input[9] = {18, 523, 301, 1234, 2, 14, 108, 150, 1928};
    int output[9];

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (size != 9) {
        if (rank == 0) printf("Please run with 9 processes.\n");
        MPI_Finalize();
        return 0;
    }

    output[rank] = reverse_digits(input[rank]);

    MPI_Gather(&output[rank], 1, MPI_INT, output, 1, MPI_INT, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Reversed array: ");
        for (int i = 0; i < 9; ++i) {
            printf("%d ", output[i]);
        }
        printf("\n");
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o a1 a1.c
mpirun --oversubscribe -np 9 ./a1
Reversed array: 81 325 103 4321 2 41 801 51 8291 
*/


Write a MPI program to find the prime numbers between 1 and 100 using two processes.

#include <stdio.h>
#include <mpi.h>

int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main(int argc, char *argv[]) {
    int rank, size;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD,Enter a word: goat
Modified word: GOAT
 &size);

    if (size != 2) {
        if (rank == 0) printf("Please run with 2 processes.\n");
        MPI_Finalize();
        return 0;
    }

    int start = (rank == 0) ? 1 : 51;
    int end = (rank == 0) ? 50 : 100;

    printf("Process %d: ", rank);
    for (int i = start; i <= end; ++i) {
        if (is_prime(i)) printf("%d ", i);
    }
    printf("\n");

    MPI_Finalize();
    return 0;
}

/*
mpicc -o a2 a2.c
mpirun -np 2 ./a2
Process 0: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 
Process 1: 53 59 61 67 71 73 79 83 89 97 
*/



Write a MPI program using standard send. The sender process sends a number to the receiver. The second process receives the number and prints it.

#include <mpi.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    int rank, size, x;
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Status status;

    if (size != 2) {
        if (rank == 0) {
            fprintf(stderr, "Please run with 2 processes.\n");
        }
        MPI_Finalize();
        return 1;
    }

    if (rank == 0) {
        printf("Enter a value in master process: ");
        fflush(stdout);
        scanf("%d", &x);
        MPI_Send(&x, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        printf("I have sent %d from process 0\n", x);
        fflush(stdout);
    } else if (rank == 1) {
        MPI_Recv(&x, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
        printf("I have received %d in process 1\n", x);
        fflush(stdout);
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc sample.c -o sample
mpirun -np 2 ./sample
Enter a value in master process: 4
I have sent 4 from process 0
I have received 4 in process 1
/*


Write a MPI program using synchronous send. The sender process sends a word to the receiver. The second process receives the word, toggles each letter of the word and sends it back to the first process. Both processes use synchronous send operations.

#include <stdio.h>
#include <mpi.h>
#include <ctype.h>

void toggle_case(char *str) {
    for (int i = 0; str[i]; i++) {
        str[i] = islower(str[i]) ? toupper(str[i]) : tolower(str[i]);
    }
}

int main(int argc, char *argv[]) {
    int rank;
    char word[100];

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    if (rank == 0) {
        printf("Enter a word: ");
        fflush(stdout); 
        scanf("%s", word);

        MPI_Ssend(word, 100, MPI_CHAR, 1, 0, MPI_COMM_WORLD);

        MPI_Recv(word, 100, MPI_CHAR, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        printf("Modified word: %s\n", word);

    } else if (rank == 1) {
        MPI_Recv(word, 100, MPI_CHAR, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        toggle_case(word);
        MPI_Ssend(word, 100, MPI_CHAR, 0, 0, MPI_COMM_WORLD);
    }
    MPI_Finalize();
    return 0;
}

/*
mpicc q1.c -o q1
mpirun -np 4 ./q1
Enter a word: goat
Modified word: GOAT
*/


Write a MPI program where the master process (process 0) sends a number to each of the slaves and the slave processes receive the number and prints it. Use standard send.

#include <stdio.h>
#include <mpi.h>

int main(int argc, char *argv[]) {
    int rank, size, number;
    MPI_Status status;
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter a number to send to the slave processes: ");
        fflush(stdout);  
        scanf("%d", &number);
        for (int i = 1; i < size; i++) {
            MPI_Send(&number, 1, MPI_INT, i, 0, MPI_COMM_WORLD);
        }
    } else {
        MPI_Recv(&number, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
        printf("Process %d received number %d from master process\n", rank, number);
    }
    MPI_Finalize();
    return 0;
}

/*mpicc -o q2 q2.c
mpirun -np 4 ./q2

Enter a number to send to the slave processes: 55
Process 1 received number 55 from master process
Process 2 received number 55 from master process
Process 3 received number 55 from master process
*/

Write a MPI program to read N elements of the array in the root process (process 0) where N is equal to the total number of processes. The root process sends one value to each of the slaves. Let even ranked process finds square of the received element and odd ranked process finds cube of received element. Use Buffered send.

#include <stdio.h>
#include <mpi.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int rank, size;
    int *array = NULL;
    int element, result;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    int buffer_size = size * (sizeof(int) + MPI_BSEND_OVERHEAD);
    void *buffer = malloc(buffer_size);
    MPI_Buffer_attach(buffer, buffer_size);

    if (rank == 0) {
        array = (int *)malloc(size * sizeof(int));
        printf("Enter %d elements: ", size);
        fflush(stdout); // Ensure prompt is displayed immediately

        for (int i = 0; i < size; i++) {
            scanf("%d", &array[i]);
        }

        for (int i = 0; i < size; i++) {
            MPI_Bsend(&array[i], 1, MPI_INT, i, 0, MPI_COMM_WORLD);
        }

        free(array);
    }

    MPI_Recv(&element, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

    if (rank % 2 == 0) {
        result = element * element; // Square for even ranks
    } else {
        result = element * element * element; // Cube for odd ranks
    }

    printf("Process %d received element %d and computed result %d\n", rank, element, result);

    MPI_Buffer_detach(&buffer, &buffer_size);
    free(buffer);

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q3 q3.c
mpirun -np 4 ./q3
Enter 4 elements: 4 3 5 7
Process 0 received element 4 and computed result 16
Process 1 received element 3 and computed result 27
Process 2 received element 5 and computed result 25
Process 3 received element 7 and computed result 343
*/


Write a MPI program to read an integer value in the root process. Root process sends this value to Process 1, Process1 sends this value to Process2 and so on. Last process sends the value back to root process. When sending the value each process will first increment the received value by one. Write the program using point to point communication routines.

#include <stdio.h>
#include <mpi.h>

int main(int argc, char *argv[]) {
    int rank, size, value;
    MPI_Status status;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (size < 2) {
        if (rank == 0) {
            printf("Please run the program with at least 2 processes.\n");
        }
        MPI_Finalize();
        return 0;
    }

    if (rank == 0) {
        printf("Enter an integer value: ");
        fflush(stdout); 
        scanf("%d", &value);
        value++;
        MPI_Send(&value, 1, MPI_INT, 1, 0, MPI_COMM_WORLD);
        MPI_Recv(&value, 1, MPI_INT, size - 1, 0, MPI_COMM_WORLD, &status);
        printf("Root process received final value: %d\n", value);
    } else {
        MPI_Recv(&value, 1, MPI_INT, rank - 1, 0, MPI_COMM_WORLD, &status);
        value++;
        int next_rank = (rank == size - 1) ? 0 : rank + 1;
        MPI_Send(&value, 1, MPI_INT, next_rank, 0, MPI_COMM_WORLD);
    }

    MPI_Finalize();
    return 0;
}

/* mpicc -o q4 q4.c
mpirun -np 4 ./q4

Enter an integer value: 5
Root process received final value: 9
*/


Write a MPI program to read N elements of an array in the master process. Let N processes including master process check the array values are prime or not.

#include <stdio.h>
#include <mpi.h>
#include <stdlib.h>
#include <math.h>

int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) return 0;
    }
    return 1;
}

int main(int argc, char *argv[]) {
    int rank, size, N;
    int *array = NULL, value;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the number of elements (N): ");
        fflush(stdout); 
        scanf("%d", &N);

        array = (int *)malloc(N * sizeof(int));

        printf("Enter %d elements: ", N);
        fflush(stdout); 
        for (int i = 0; i < N; i++) {
            scanf("%d", &array[i]);
        }
    }

    MPI_Bcast(&N, 1, MPI_INT, 0, MPI_COMM_WORLD);

    if (rank != 0) {
        array = (int *)malloc(N * sizeof(int));
    }

    MPI_Bcast(array, N, MPI_INT, 0, MPI_COMM_WORLD);

    if (rank < N) {
        value = array[rank];
        printf("Process %d checking value %d: %s\n", rank, value, is_prime(value) ? "Prime" : "Not Prime");
    }

    free(array);
    MPI_Finalize();
    return 0;
}

/*
mpicc -o a1 a1.c -lm
mpirun -np 4 ./a1
Enter the number of elements (N): 5
Enter 5 elements: 11 12 13 14 15
Process 0 checking value 11: Prime
Process 1 checking value 12: Not Prime
Process 2 checking value 13: Prime
Process 3 checking value 14: Not Prime
*/

Write a MPI program to read N values in the root process. Root process sends one value to each process. Every process receives it and finds the factorial of that number and returns it to the root process. Root process gathers the factorial and finds sum of it. Use N number of processes.

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

long long factorial(int n) {
    long long result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

int main(int argc, char** argv) {
    int rank, size, N;
    int* values = NULL;
    long long factorial_result, sum = 0;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the number of values (N): ");
        fflush(stdout); 
        scanf("%d", &N);

        if (N != size) {
            fprintf(stderr, "Error: Number of processes must match N.\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        values = (int*)malloc(N * sizeof(int));
        if (values == NULL) {
            fprintf(stderr, "Error: Memory allocation failed.\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        printf("Enter %d values: ", N);
        fflush(stdout); 
        for (int i = 0; i < N; ++i) {
            scanf("%d", &values[i]);
        }
    }

    int value;

    MPI_Scatter(values, 1, MPI_INT, &value, 1, MPI_INT, 0, MPI_COMM_WORLD);

    factorial_result = factorial(value);

    if (rank == 0) {
        long long* factorials = (long long*)malloc(N * sizeof(long long));
        if (factorials == NULL) {
            fprintf(stderr, "Error: Memory allocation failed.\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        MPI_Gather(&factorial_result, 1, MPI_LONG_LONG, factorials, 1, MPI_LONG_LONG, 0, MPI_COMM_WORLD);

        for (int i = 0; i < N; ++i) {
            sum += factorials[i];
        }

        printf("Sum of factorials: %lld\n", sum);

        free(values);
        free(factorials);
    } else {
        MPI_Gather(&factorial_result, 1, MPI_LONG_LONG, NULL, 0, MPI_LONG_LONG, 0, MPI_COMM_WORLD);
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q1 q1.c
mpirun -np 4 ./q1
Enter the number of values (N): 4 
Enter 4 values: 1 2 3 4
Sum of factorials: 33
*/

Write a MPI program to read an integer value M and NXM elements into an ID array in the root process, where N is the number of processes. Root process sends M elements to each process. Each process finds average of M elements it received and sends these average values to root. Root collects all the values and finds the total average. Use collective communication routines.

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

double calculate_average(int* elements, int count) {
    int sum = 0;
    for (int i = 0; i < count; ++i) {
        sum += elements[i];
    }
    return (double)sum / count;
}

int main(int argc, char** argv) {
    int rank, size, M;
    int* id_array = NULL;
    double* averages = NULL;
    double total_sum = 0.0, total_average = 0.0;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the value of M: ");
        fflush(stdout);
        scanf("%d", &M);

        int N = size;
        int total_elements = N * M;
        id_array = (int*)malloc(total_elements * sizeof(int));
        averages = (double*)malloc(N * sizeof(double));

        printf("Enter %d elements into the ID array:\n", total_elements);
	fflush(stdout);
        for (int i = 0; i < total_elements; ++i) {
            scanf("%d", &id_array[i]);
        }
    } else {
        id_array = (int*)malloc(1 * sizeof(int));
    }

    int* sub_array = (int*)malloc(M * sizeof(int));

    MPI_Bcast(&M, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Scatter(id_array, M, MPI_INT, sub_array, M, MPI_INT, 0, MPI_COMM_WORLD);

    double sub_average = calculate_average(sub_array, M);

    MPI_Gather(&sub_average, 1, MPI_DOUBLE, averages, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    if (rank == 0) {
        for (int i = 0; i < size; ++i) {
            total_sum += averages[i];
        }
        total_average = total_sum / size;
        printf("Total average: %.2f\n", total_average);

        free(id_array);
        free(averages);
    } else {
        free(id_array);
    }

    free(sub_array);

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q2 q2.c
mpirun -np 2 ./q2
Enter the value of M: 2
Enter 4 elements into the ID array:
1 2 3 4
Total average: 2.50
*/

Write a MPI program to read a string. Using N processes (string length is evenly divisible by N), find the number of non-vowels in the string. In the root process print number of non- vowels found by each process and print the total number of non-vowels.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mpi.h>

#define MAX_STRING_LENGTH 1000

int is_vowel(char c) {
    char vowels[] = "aeiouAEIOU";
    for (int i = 0; i < strlen(vowels); i++) {
        if (c == vowels[i]) {
            return 1; 
        }
    }
    return 0; 
}

int main(int argc, char** argv) {
    int rank, size;
    char input_string[MAX_STRING_LENGTH];
    int local_count = 0, total_count = 0;
    int segment_length;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter a string: ");
	fflush(stdout);
        fgets(input_string, MAX_STRING_LENGTH, stdin);
        input_string[strcspn(input_string, "\n")] = 0;
    }

    MPI_Bcast(input_string, MAX_STRING_LENGTH, MPI_CHAR, 0, MPI_COMM_WORLD);

    int string_length = strlen(input_string);
    segment_length = string_length / size;

    for (int i = rank * segment_length; i < (rank + 1) * segment_length; i++) {
        if (!is_vowel(input_string[i])) {
            local_count++;
        }
    }

    MPI_Reduce(&local_count, &total_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Total number of non-vowels: %d\n", total_count);
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q3 q3.c
mpirun -np 4 ./q3

Enter a string: noOn
Total number of non-vowels: 2
*/

Write a MPI Program to read two strings S1 and S2 of same length in the root process. Using N processes including the root (string length is evenly divisible by N), produce the resultant string as shown below. Display the resultant string in the root process. Use Collective communication routines.
Example:
String S1: string
String S2: length
Resultant String : slternigntgh

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void interleave_strings(char* segment1, char* segment2, char* result_segment, int length) {
    for (int i = 0; i < length; ++i) {
        result_segment[2 * i] = segment1[i];
        result_segment[2 * i + 1] = segment2[i];
    }}

int main(int argc, char** argv) {
    int rank, size, segment_length;
    char *S1 = NULL, *S2 = NULL, *result = NULL;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        S1 = (char*)malloc(100 * sizeof(char));
        S2 = (char*)malloc(100 * sizeof(char));
        printf("Enter first string (S1): ");
	fflush(stdout);
        fgets(S1, 100, stdin);
        S1[strcspn(S1, "\n")] = '\0';

        printf("Enter second string (S2): ");
	fflush(stdout);
        fgets(S2, 100, stdin);
        S2[strcspn(S2, "\n")] = '\0'; 

        int length = strlen(S1);
        if (length % size != 0 || length != strlen(S2)) {
            fprintf(stderr, "Error");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        segment_length = length / size;
        result = (char*)malloc(2 * length * sizeof(char));
    }


    MPI_Bcast(&segment_length, 1, MPI_INT, 0, MPI_COMM_WORLD);

    char* segment1 = (char*)malloc((segment_length + 1) * sizeof(char));
    char* segment2 = (char*)malloc((segment_length + 1) * sizeof(char));
    char* result_segment = (char*)malloc((2 * segment_length + 1) * sizeof(char));

    MPI_Scatter(S1, segment_length, MPI_CHAR, segment1, segment_length, MPI_CHAR, 0, MPI_COMM_WORLD);
    MPI_Scatter(S2, segment_length, MPI_CHAR, segment2, segment_length, MPI_CHAR, 0, MPI_COMM_WORLD);
    segment1[segment_length] = '\0'; 
    segment2[segment_length] = '\0'; 

    interleave_strings(segment1, segment2, result_segment, segment_length);
    result_segment[2 * segment_length] = '\0'; 

    MPI_Gather(result_segment, 2 * segment_length, MPI_CHAR, result, 2 * segment_length, MPI_CHAR, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        result[2 * segment_length * size] = '\0'; 
        printf("Resultant String: %s\n", result);

        free(S1);
        free(S2);
        free(result);
    }

    free(segment1);
    free(segment2);
    free(result_segment);

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q4 q4.c
mpirun -np 3 ./q4

Enter first string (S1): string
Enter second string (S2): length
Resultant String: slternigntgh
*/


Write a MPI program to read a value M and NXM number of elements into ID array in the root, where N is the total number of processes. Find the square of first M numbers, the cube of next M numbers and so on. Print the results in the root. use collective communication

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(int argc, char** argv) {
    int rank, size, M;
    int *ID = NULL, *local_data = NULL, *result = NULL;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the value of M: ");
        fflush(stdout);
        scanf("%d", &M);

        ID = (int*)malloc(size * M * sizeof(int));
        printf("Enter %d elements into the ID array: ", size * M);
        fflush(stdout);
        for (int i = 0; i < size * M; i++) {
            scanf("%d", &ID[i]);
        }
    }

    MPI_Bcast(&M, 1, MPI_INT, 0, MPI_COMM_WORLD);

    local_data = (int*)malloc(M * sizeof(int));

    MPI_Scatter(ID, M, MPI_INT, local_data, M, MPI_INT, 0, MPI_COMM_WORLD);

    int* local_result = (int*)malloc(M * sizeof(int));

    int power = rank + 2;
    for (int i = 0; i < M; i++) {
        local_result[i] = (int)pow(local_data[i], power);
    }

    if (rank == 0) {
        result = (int*)malloc(size * M * sizeof(int));
    }

    MPI_Gather(local_result, M, MPI_INT, result, M, MPI_INT, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("\nResults:\n");
        for (int i = 0; i < size; i++) {
            printf("Power %d: ", i + 2);
            for (int j = 0; j < M; j++) {
                printf("%d ", result[i * M + j]);
            }
            printf("\n");
        }
        free(ID);
        free(result);
    }

    free(local_data);
    free(local_result);

    MPI_Finalize();
    return 0;
}

/*
mpicc -o a1 a1.c -lm
mpirun -np 4 ./a1
Enter the value of M: 2
Enter 8 elements into the ID array: 1 2 3 4 5 6 7 8

Results:
Power 2: 1 4 
Power 3: 27 64 
Power 4: 625 1296 
Power 5: 16807 32768 
*/

Write a MPI program using collective communication functions, to replace all even elements of array A to 1 and replace all odd elements to 0 of size N. Display the resultant array A, count of all even and odd numbers in root process. Assume N is evenly divisible by number of processes.
Example:
Input Array (A):
1 2 3 4 5 6 7 8 9
Resultant Array (A): 0 1 0 1 0 1 0 1 0
Even (Count) = 4
Odd (Count) = 5

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

void process_array(int *sub_array, int sub_size, int *even_count, int *odd_count) {
    *even_count = 0;
    *odd_count = 0;
    for (int i = 0; i < sub_size; i++) {
        if (sub_array[i] % 2 == 0) {
            sub_array[i] = 1; 
            (*even_count)++;
        } else {
            sub_array[i] = 0; 
            (*odd_count)++;
        }
    }}

int main(int argc, char *argv[]) {
    int rank, size, N;
    int *A = NULL;
    int even_count = 0, odd_count = 0;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the size of array (N): ");
	fflush(stdout);
        scanf("%d", &N);

        if (N % size != 0) {
            fprintf(stderr, "Error: N must be evenly divisible by number of processes.\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }

        A = (int *)malloc(N * sizeof(int));
        printf("Enter %d elements of array: ", N);
	fflush(stdout);
        for (int i = 0; i < N; i++) {
            scanf("%d", &A[i]);
        }
    }

    MPI_Bcast(&N, 1, MPI_INT, 0, MPI_COMM_WORLD);

    int sub_size = N / size;
    int *sub_array = (int *)malloc(sub_size * sizeof(int));

    MPI_Scatter(A, sub_size, MPI_INT, sub_array, sub_size, MPI_INT, 0, MPI_COMM_WORLD);

    int local_even = 0, local_odd = 0;
    process_array(sub_array, sub_size, &local_even, &local_odd);

    MPI_Gather(sub_array, sub_size, MPI_INT, A, sub_size, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_even, &even_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_odd, &odd_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Resultant Array (A): ");
        for (int i = 0; i < N; i++) {
            printf("%d ", A[i]);
        }
        printf("\n");

        printf("Even (Count) = %d\n", even_count);
        printf("Odd (Count) = %d\n", odd_count);

        free(A);
    }

    free(sub_array);
    MPI_Finalize();
    return 0;
}

/*
mpicc -o a2 a2.c -lm
mpirun -np 3 ./a2

Enter the size of array (N): 9
Enter 9 elements of array: 1 2 3 4 5 6 7 8 9
Resultant Array (A): 0 1 0 1 0 1 0 1 0 
Even (Count) = 4
Odd (Count) = 5
*/


Write a MPI program to read N values of the array in the root process. Distribute these N values among N processes. Every process finds the square of the value it received. Let every process return these values to the root and root process gathers and prints the result. Use collective communication routines.

#include "mpi.h"
#include <stdio.h>

int main(int argc, char *argv[]) {
    int rank, size, N, A[10], B[10], c, i;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        N = size;  
        printf("Enter %d values:\n", N);
        fflush(stdout);

        for (i = 0; i < N; i++) {
            scanf("%d", &A[i]);
        }
    }

    MPI_Bcast(&N, 1, MPI_INT, 0, MPI_COMM_WORLD);

    MPI_Scatter(A, 1, MPI_INT, &c, 1, MPI_INT, 0, MPI_COMM_WORLD);
    printf("I have received %d in process %d\n", c, rank);
    fflush(stdout);

    c = c * c;

    MPI_Gather(&c, 1, MPI_INT, B, 1, MPI_INT, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("The Result gathered in the root:\n");
        for (i = 0; i < N; i++) {
            printf("%d\t", B[i]);
        }
        printf("\n");
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o sample sample.c
mpirun -np 4 ./sample
Enter 4 values:
2 3 4 5
I have received 2 in process 0
I have received 4 in process 2
I have received 3 in process 1
I have received 5 in process 3
The Result gathered in the root:
4	9	16	25	


Write a MPI program using N processes to find 1! + 2! +.....+N!. Use collective communication routines.

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>

int compute_factorial(int n) {
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
    }
    return fact;
}

int main(int argc, char *argv[]) {
    int rank, size, local_fact, factsum = 0, provided;

    MPI_Init_thread(&argc, &argv, MPI_THREAD_SINGLE, &provided);
    if (provided < MPI_THREAD_SINGLE) {
        fprintf(stderr, "Error: MPI does not provide required threading level\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (size < 1) {
        if (rank == 0) {
            fprintf(stderr, "Error: Number of processes must be at least 1\n");
        }
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    local_fact = compute_factorial(rank + 1);

    printf("Process %d calculated %d! = %d\n", rank, rank + 1, local_fact);
    fflush(stdout);

    MPI_Reduce(&local_fact, &factsum, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Sum of factorials: %d\n", factsum);
	fflush(stdout);
    }

    MPI_Finalize();
    return 0;
}

/*mpicc -o sample sample.c -lm
mpirun -np 4 ./sample

Process 0 calculated 1! = 1
Process 1 calculated 2! = 2
Process 2 calculated 3! = 6
Process 3 calculated 4! = 24
Sum of factorials: 33 */


Write a MPI program using N processes to find 1! + 2! +.....+N!. Use scan. Also, handle different errors using error handling routines.

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>

unsigned long long factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    unsigned long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main(int argc, char** argv) {
    int rank, size;
    int N;
    unsigned long long local_factorial, global_sum;

    int mpi_error = MPI_Init(&argc, &argv);
    if (mpi_error != MPI_SUCCESS) {
        fprintf(stderr, "Error initializing MPI\n");
        MPI_Abort(MPI_COMM_WORLD, mpi_error);
        return EXIT_FAILURE;
    }

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter the value of N: ");fflush(stdout);
        if (scanf("%d", &N) != 1 || N < 1) {
            fprintf(stderr, "Invalid input. N must be a positive integer.\n");
            MPI_Abort(MPI_COMM_WORLD, EXIT_FAILURE);
            return EXIT_FAILURE;
        }
    }

    MPI_Bcast(&N, 1, MPI_INT, 0, MPI_COMM_WORLD);

    local_factorial = factorial(rank + 1); 

    MPI_Scan(&local_factorial, &global_sum, 1, MPI_UNSIGNED_LONG_LONG, MPI_SUM, MPI_COMM_WORLD);

    if (rank == size - 1) { 
        printf("The sum of factorials from 1! to %d! is: %llu\n", N, global_sum);
    }

    mpi_error = MPI_Finalize();
    if (mpi_error != MPI_SUCCESS) {
        fprintf(stderr, "Error finalizing MPI\n");
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

/*
mpicc -o q1 q1.c
mpirun -np 4 ./q1

Enter the value of N: 5
The sum of factorials from 1! to 5! is: 33
*/

Write a MPI program to read a 3 X 3 matrix. Enter an element to be searched in the root process. Find the number of occurrences of this element in the matrix using three processes.

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv) {
    int rank, size, element, occurrences = 0, total_occurrences = 0;
    int matrix[3][3];

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (size != 3) {
        if (rank == 0) {
            fprintf(stderr, "Error: Program requires exactly 3 processes.\n");
        }
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    if (rank == 0) {
        printf("Enter 3x3 matrix elements:\n");
	fflush(stdout);
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                scanf("%d", &matrix[i][j]);
            }
        }

        printf("Enter element to be searched: ");fflush(stdout);	
        scanf("%d", &element);
    }

    MPI_Bcast(&element, 1, MPI_INT, 0, MPI_COMM_WORLD);

    int row[3];
    MPI_Scatter(matrix, 3, MPI_INT, row, 3, MPI_INT, 0, MPI_COMM_WORLD);

    for (int i = 0; i < 3; ++i) {
        if (row[i] == element) {
            occurrences++;
        }
    }

    MPI_Reduce(&occurrences, &total_occurrences, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    if (rank == 0) {
        printf("Total occurrences of element %d: %d\n", element, total_occurrences);
    }

    MPI_Finalize();
    return 0;
}

/*
mpicc -o q2 q2.c
mpirun -np 3 ./q2

Enter 3x3 matrix elements:
1 2 3
4 5 6 
7 8 9
Enter element to be searched: 3
Total occurrences of element 3: 1
*/

Write a MPI program to read 4 X 4 matrix and display the following output using four processes.
I/p matrix: 
1 2 3 4
1 2 3 1
1 1 1 1 
2 1 2 1
O/p matrix: 
1 2 3 4
2 4 6 5
3 5 7 6
5 6 9 7

#include <stdio.h>
#include <mpi.h>

#define N 4

int main(int argc, char *argv[]) {
    int rank, size;
    int matrix[N][N];
    int modified[N][N] = {0};

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        printf("Enter a 4x4 matrix:\n");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                scanf("%d", &matrix[i][j]);
            }
        }}

    MPI_Bcast(matrix, N * N, MPI_INT, 0, MPI_COMM_WORLD);

    for (int j = rank; j < N; j += size) {
        modified[0][j] = matrix[0][j];
        for (int i = 1; i < N; i++) {
            modified[i][j] = modified[i - 1][j] + matrix[i][j];
        }
    }

    int final_matrix[N][N];
    MPI_Reduce(modified, final_matrix, N * N, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        printf("Output:\n");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%d ", final_matrix[i][j]);
            }
            printf("\n");
        }
    }

    MPI_Finalize();
    return 0;
}

/* mpicc -o q3 q3.c
mpirun -np 4 ./q3 

Enter a 4x4 matrix:
1 2 3 4
1 2 3 1
1 1 1 1
2 1 2 1
Output:
1 2 3 4 
2 4 6 5 
3 5 7 6 
5 6 9 7 
*/

Write a MPI program to read a word of length N. Using N processes including the root get output word with the pattern as shown in example. Display the resultant output word in the root.
Example: Input: PCAP
Output: PCCAAAPPPP

#include <mpi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int rank, size;
    char input_word[100];
    char *result = NULL;
    int word_length;
    
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    
    if (rank == 0) {
        printf("Enter a word: ");
        fflush(stdout);
        scanf("%s", input_word);
        word_length = strlen(input_word);
        

        if (word_length != size) {
            printf("Error: Number of processes (%d) must match word length (%d)\n", 
                   size, word_length);
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
    }
    

    MPI_Bcast(&word_length, 1, MPI_INT, 0, MPI_COMM_WORLD);
    

    MPI_Bcast(input_word, word_length + 1, MPI_CHAR, 0, MPI_COMM_WORLD);
    

    int total_length = 0;
    for (int i = 0; i < word_length; i++) {
        total_length += (i + 1);
    }
    
    if (rank == 0) {
        result = (char*)malloc(total_length + 1);
        result[total_length] = '\0';
    }
    

    char current_char = input_word[rank];
    int repetitions = rank + 1;
    char *local_pattern = (char*)malloc(repetitions);
    
    for (int i = 0; i < repetitions; i++) {
        local_pattern[i] = current_char;
    }
    

    int *counts = NULL;
    int *displs = NULL;
    if (rank == 0) {
        counts = (int*)malloc(size * sizeof(int));
        displs = (int*)malloc(size * sizeof(int));
        
        int offset = 0;
        for (int i = 0; i < size; i++) {
            counts[i] = i + 1;
            displs[i] = offset;
            offset += (i + 1);
        }    }
    

    MPI_Gatherv(local_pattern, repetitions, MPI_CHAR,
                result, counts, displs, MPI_CHAR,
                0, MPI_COMM_WORLD);
    
    if (rank == 0) {
        printf("Output: %s\n", result);
        free(result);
        free(counts);
        free(displs);
    }
    
    free(local_pattern);
    MPI_Finalize();
    return 0;
}

/*
mpicc -o q4 q4.c
mpirun -np 4 ./q4

Enter a word: pcap
Output: pccaaapppp
*/


CUDA Program to Add Two Numbers

#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <stdio.h>

__global__ void add(int *a, int *b, int *c) {
    *c = *a + *b;
}

int main(void) {
    int a, b, c;               // Host copies of variables
    int *d_a, *d_b, *d_c;      // Device copies of variables
    int size = sizeof(int);

    cudaMalloc((void **)&d_a, size);
    cudaMalloc((void **)&d_b, size);
    cudaMalloc((void **)&d_c, size);

    a = 3;
    b = 5;

    cudaMemcpy(d_a, &a, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_b, &b, size, cudaMemcpyHostToDevice);

    add<<<1, 1>>>(d_a, d_b, d_c);

    cudaMemcpy(&c, d_c, size, cudaMemcpyDeviceToHost);

    printf("Result: %d\n", c);

    cudaFree(d_a);
    cudaFree(d_b);
    cudaFree(d_c);

    return 0;
}

/* 
nvcc sample.cu -o sample
./sample

Result: 8
*/


Write a program in CUDA to add two vectors of length N using block size as N

#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <stdio.h>

__global__ void add(int *a, int *b, int *c, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < N) {
        c[idx] = a[idx] + b[idx];
    }}

void check_cuda_error(const char *msg) {
    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("CUDA Error after %s: %s\n", msg, cudaGetErrorString(err));
        exit(-1);
    }}

int main(void) {
    int N;

    printf("Enter length of vectors (N): ");
    scanf("%d", &N);

    int size = N * sizeof(int); 

    int *a, *b, *c;  
    int *d_a, *d_b, *d_c; 

    a = (int *)malloc(size);
    b = (int *)malloc(size);
    c = (int *)malloc(size);

    printf("Enter elements of vector a:\n");
    for (int i = 0; i < N; i++) {
        printf("a[%d]: ", i);
        scanf("%d", &a[i]);
    }

    printf("Enter elements of vector b:\n");
    for (int i = 0; i < N; i++) {
        printf("b[%d]: ", i);
        scanf("%d", &b[i]);
    }

    cudaMalloc((void **)&d_a, size);
    check_cuda_error("cudaMalloc d_a");

    cudaMalloc((void **)&d_b, size);
    check_cuda_error("cudaMalloc d_b");

    cudaMalloc((void **)&d_c, size);
    check_cuda_error("cudaMalloc d_c");

    cudaMemcpy(d_a, a, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_a");

    cudaMemcpy(d_b, b, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_b");

    add<<<1, N>>>(d_a, d_b, d_c, N);
    check_cuda_error("Kernel launch");

    cudaDeviceSynchronize();

    cudaMemcpy(c, d_c, size, cudaMemcpyDeviceToHost);
    check_cuda_error("cudaMemcpy d_c");

    printf("\nResult of vector addition:\n");
    for (int i = 0; i < N; i++) {
        printf("c[%d] = %d\n", i, c[i]);
    }

    free(a);
    free(b);
    free(c);
    cudaFree(d_a);
    cudaFree(d_b);
    cudaFree(d_c);

    return 0;
}

/*
nvcc q1aa.cu -o q1aa -lcuda
./q1aa

Enter length of vectors (N): 5
Enter elements of vector a:
a[0]: 1
a[1]: 2
a[2]: 3
a[3]: 4
a[4]: 5
Enter elements of vector b:
b[0]: 11
b[1]: 22
b[2]: 33
b[3]: 44
b[4]: 55

Result of vector addition:
c[0] = 12
c[1] = 24
c[2] = 36
c[3] = 48
c[4] = 60
*/

Write a program in CUDA to add two vectors of length N using N threads

#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <stdio.h>
#include <stdlib.h>

__global__ void add(int *a, int *b, int *c, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < N) {
        c[idx] = a[idx] + b[idx];
    }
}

void check_cuda_error(const char *msg) {
    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("CUDA Error after %s: %s\n", msg, cudaGetErrorString(err));
        exit(-1);
    }
}

int main(void) {
    int N;
    printf("Enter length of vectors (N): ");
    scanf("%d", &N);

    int size = N * sizeof(int);
    int *a, *b, *c;
    int *d_a, *d_b, *d_c;

    a = (int *)malloc(size);
    b = (int *)malloc(size);
    c = (int *)malloc(size);

    printf("Enter elements of vector a:\n");
    for (int i = 0; i < N; i++) {
        printf("a[%d]: ", i);
        scanf("%d", &a[i]);
    }

    printf("Enter elements of vector b:\n");
    for (int i = 0; i < N; i++) {
        printf("b[%d]: ", i);
        scanf("%d", &b[i]);
    }

    cudaMalloc((void **)&d_a, size);
    check_cuda_error("cudaMalloc d_a");
    cudaMalloc((void **)&d_b, size);
    check_cuda_error("cudaMalloc d_b");
    cudaMalloc((void **)&d_c, size);
    check_cuda_error("cudaMalloc d_c");

    cudaMemcpy(d_a, a, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_a");
    cudaMemcpy(d_b, b, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_b");

    int threadsPerBlock = 256;
    int blocksPerGrid = (N + threadsPerBlock - 1) / threadsPerBlock;  // Ensures all elements are covered

    add<<<blocksPerGrid, threadsPerBlock>>>(d_a, d_b, d_c, N);
    check_cuda_error("Kernel launch");

    cudaDeviceSynchronize();
    check_cuda_error("cudaDeviceSynchronize");

    cudaMemcpy(c, d_c, size, cudaMemcpyDeviceToHost);
    check_cuda_error("cudaMemcpy d_c");

    printf("\nResult of vector addition:\n");
    for (int i = 0; i < N; i++) {
        printf("c[%d] = %d\n", i, c[i]);
    }

    free(a);
    free(b);
    free(c);
    cudaFree(d_a);
    cudaFree(d_b);
    cudaFree(d_c);
    return 0;
}

/*
nvcc q1b.cu -o q1b -lcuda
./q1b

Enter length of vectors (N): 5
Enter elements of vector a:
a[0]: 1
a[1]: 2
a[2]: 3
a[3]: 4
a[4]: 5
Enter elements of vector b:
b[0]: 11
b[1]: 22
b[2]: 33
b[3]: 44
b[4]: 55

Result of vector addition:
c[0] = 12
c[1] = 24
c[2] = 36
c[3] = 48
c[4] = 60
*/

Implement a CUDA program to add two vectors of length N by keeping the number of threads per block as 256 (constant) and vary the number of blocks to handle N elements.

#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <stdio.h>
#include <stdlib.h>

#define THREADS_PER_BLOCK 256 

__global__ void add(int *a, int *b, int *c, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < N) {
        c[idx] = a[idx] + b[idx];
    }}

void check_cuda_error(const char *msg) {
    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("CUDA Error after %s: %s\n", msg, cudaGetErrorString(err));
        exit(-1);
    }}

int main(void) {
    int N;
    printf("Enter length of vectors (N): ");
    scanf("%d", &N);

    int size = N * sizeof(int);
    int *a, *b, *c;
    int *d_a, *d_b, *d_c;

    a = (int *)malloc(size);
    b = (int *)malloc(size);
    c = (int *)malloc(size);

    printf("Enter elements of vector a:\n");
    for (int i = 0; i < N; i++) {
        printf("a[%d]: ", i);
        scanf("%d", &a[i]);
    }

    printf("Enter elements of vector b:\n");
    for (int i = 0; i < N; i++) {
        printf("b[%d]: ", i);
        scanf("%d", &b[i]);
    }

    cudaMalloc((void **)&d_a, size);
    check_cuda_error("cudaMalloc d_a");
    cudaMalloc((void **)&d_b, size);
    check_cuda_error("cudaMalloc d_b");
    cudaMalloc((void **)&d_c, size);
    check_cuda_error("cudaMalloc d_c");

    cudaMemcpy(d_a, a, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_a");
    cudaMemcpy(d_b, b, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_b");

    int blocksPerGrid = (N + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;

    add<<<blocksPerGrid, THREADS_PER_BLOCK>>>(d_a, d_b, d_c, N);
    check_cuda_error("Kernel launch");

    cudaDeviceSynchronize();
    check_cuda_error("cudaDeviceSynchronize");

    cudaMemcpy(c, d_c, size, cudaMemcpyDeviceToHost);
    check_cuda_error("cudaMemcpy d_c");

    printf("\nResult of vector addition:\n");
    for (int i = 0; i < N; i++) {
        printf("c[%d] = %d\n", i, c[i]);
    }

    free(a);
    free(b);
    free(c);
    cudaFree(d_a);
    cudaFree(d_b);
    cudaFree(d_c);
    return 0;
}

/*
nvcc q2.cu -o q2 -lcuda
./q2
Enter length of vectors (N): 3
Enter elements of vector a:
a[0]: 1 
a[1]: 2
a[2]: 3
Enter elements of vector b:
b[0]: 6
b[1]: 5
b[2]: 4

Result of vector addition:
c[0] = 7
c[1] = 7
c[2] = 7
*/

Write a program in CUDA to process a 1D array containing angles in radians to generate sine of the angles in the output array. Use appropriate function.

#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define THREADS_PER_BLOCK 256  

__global__ void compute_sine(float *input, float *output, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < N) {
        output[idx] = sinf(input[idx]);  // Compute sine for each angle
    }}

void check_cuda_error(const char *msg) {
    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("CUDA Error after %s: %s\n", msg, cudaGetErrorString(err));
        exit(-1);
    }}

int main(void) {
    int N;
    printf("Enter the number of angles: ");
    scanf("%d", &N);

    int size = N * sizeof(float);
    float *h_input, *h_output;
    float *d_input, *d_output;

    h_input = (float *)malloc(size);
    h_output = (float *)malloc(size);

    printf("Enter angles in radians:\n");
    for (int i = 0; i < N; i++) {
        printf("angle[%d]: ", i);
        scanf("%f", &h_input[i]);
    }

    cudaMalloc((void **)&d_input, size);
    check_cuda_error("cudaMalloc d_input");
    cudaMalloc((void **)&d_output, size);
    check_cuda_error("cudaMalloc d_output");

    cudaMemcpy(d_input, h_input, size, cudaMemcpyHostToDevice);
    check_cuda_error("cudaMemcpy d_input");

    int blocksPerGrid = (N + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;

    compute_sine<<<blocksPerGrid, THREADS_PER_BLOCK>>>(d_input, d_output, N);
    check_cuda_error("Kernel launch");

    cudaDeviceSynchronize();
    check_cuda_error("cudaDeviceSynchronize");

    cudaMemcpy(h_output, d_output, size, cudaMemcpyDeviceToHost);
    check_cuda_error("cudaMemcpy d_output");

    printf("\nSine values of input angles:\n");
    for (int i = 0; i < N; i++) {
        printf("sin(%.4f) = %.4f\n", h_input[i], h_output[i]);
    }

    free(h_input);
    free(h_output);
    cudaFree(d_input);
    cudaFree(d_output);
    return 0;
}

/*
nvcc q3.cu -o q3 -lcuda
./q3

Enter the number of angles: 5
Enter angles in radians:
angle[0]: 0.0
angle[1]: 1.5708
angle[2]: 3.1416
angle[3]: 4.7124
angle[4]: 6.2832

Sine values of input angles:
sin(0.0000) = 0.0000
sin(1.5708) = 1.0000
sin(3.1416) = -0.0000
sin(4.7124) = -1.0000
sin(6.2832) = 0.0000
*/


/*write a program in CUDA to perform linear algebra function of the form y = ax + y, where x and y are vectors and a is a scalar value.*/
#include <stdio.h>
#include <cuda.h>

__global__ void vectorAdd(float *x, float *y, float a, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < n) {
        y[idx] += a * x[idx]; 
    }
}

int main() {
    int n;
    float *h_x, *h_y, *d_x, *d_y, a;

    printf("Enter size of the vectors: ");
    scanf("%d", &n);

    h_x = (float *)malloc(n * sizeof(float));
    h_y = (float *)malloc(n * sizeof(float));

    printf("Enter elements of vector x:\n");
    for (int i = 0; i < n; i++) {
        printf("x[%d]: ", i);
        scanf("%f", &h_x[i]);
    }

    printf("Enter elements of vector y:\n");
    for (int i = 0; i < n; i++) {
        printf("y[%d]: ", i);
        scanf("%f", &h_y[i]);
    }

    printf("Enter scalar value a: ");
    scanf("%f", &a);

    cudaMalloc((void**)&d_x, n * sizeof(float));
    cudaMalloc((void**)&d_y, n * sizeof(float));

    cudaMemcpy(d_x, h_x, n * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_y, h_y, n * sizeof(float), cudaMemcpyHostToDevice);

    int blockSize = 256;
    int numBlocks = (n + blockSize - 1) / blockSize;
    vectorAdd<<<numBlocks, blockSize>>>(d_x, d_y, a, n);

    cudaMemcpy(h_y, d_y, n * sizeof(float), cudaMemcpyDeviceToHost);

    printf("Resulting vector y: ");
    for (int i = 0; i < n; i++) {
        printf("%f ", h_y[i]);
    }
    printf("\n");


    cudaFree(d_x);
    cudaFree(d_y);
    free(h_x);
    free(h_y);

    return 0;
}

/*nvcc -o a1 a1.cu
./a1
Enter size of the vectors: 3
Enter elements of vector x:
x[0]: 1
x[1]: 2
x[2]: 3
Enter elements of vector y:
y[0]: 10
y[1]: 20
y[2]: 30
Enter scalar value a: 2
Resulting vector y: 12.000000 24.000000 36.000000 
*/


/*write a program in CUDA to sort every row of a matrix using selection sort.*/
#include <stdio.h>
#include <cuda.h>
#include <stdlib.h>
 
__global__ void rowSelectionSort(int *matrix, int n, int m) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;
    if (row < n) {
        for (int i = 0; i < m - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < m; j++) {
                if (matrix[row * m + j] < matrix[row * m + minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                int temp = matrix[row * m + i];
                matrix[row * m + i] = matrix[row * m + minIdx];
                matrix[row * m + minIdx] = temp;
            }
        }    }}
 
int main() {
    int n, m;
    printf("Enter number of rows (N): ");
    scanf("%d", &n);
    printf("Enter number of columns (M): ");
    scanf("%d", &m);
 
    int *h_matrix = (int*) malloc(n * m * sizeof(int));
    printf("Enter %d x %d matrix elements:\n", n, m);
    for (int i = 0; i < n * m; i++) {
        scanf("%d", &h_matrix[i]);
    }
 
    int *d_matrix;
    cudaMalloc(&d_matrix, n * m * sizeof(int));
    cudaMemcpy(d_matrix, h_matrix, n * m * sizeof(int), cudaMemcpyHostToDevice);

    int blockSize = 256;
    int gridSize = (n + blockSize - 1) / blockSize;
    rowSelectionSort<<<gridSize, blockSize>>>(d_matrix, n, m);
    cudaDeviceSynchronize();
 
    cudaMemcpy(h_matrix, d_matrix, n * m * sizeof(int), cudaMemcpyDeviceToHost);
 
    printf("Sorted matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", h_matrix[i * m + j]);
        printf("\n");
    }
 
    free(h_matrix);
    cudaFree(d_matrix);
    return 0;
}

/*
nvcc -o a2 a2.cu
./a2
Enter number of rows (N): 3
Enter number of columns (M): 4
Enter 3 x 4 matrix elements:
9 2 4 8
5 1 7 3
6 0 2 4
Sorted matrix:
2 4 8 9 
1 3 5 7 
0 2 4 6 
*/

/*write a program in CUDA to perform odd even transposition sort in parallel*/

#include <stdio.h>
#include <cuda.h>
 
__global__ void oddEvenSort(int *arr, int n, int phase) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int i = 2 * idx + (phase % 2); 
    if (i < n - 1) {
        if (arr[i] > arr[i + 1]) {
            int temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }}
 
void oddEvenSortCUDA(int *h_arr, int n) {
    int *d_arr;
    cudaMalloc(&d_arr, n * sizeof(int));
    cudaMemcpy(d_arr, h_arr, n * sizeof(int), cudaMemcpyHostToDevice);
 
    int threads = 256;
    int blocks = (n / 2 + threads - 1) / threads;
 
    for (int phase = 0; phase < n; phase++) {
        oddEvenSort<<<blocks, threads>>>(d_arr, n, phase);
        cudaDeviceSynchronize();
    }
 
    cudaMemcpy(h_arr, d_arr, n * sizeof(int), cudaMemcpyDeviceToHost);
    cudaFree(d_arr);
}
 
int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
 
    int *h_arr = (int*) malloc(n * sizeof(int));
    printf("Enter %d elements:\n", n);
    for (int i = 0; i < n; i++)
        scanf("%d", &h_arr[i]);
 
    oddEvenSortCUDA(h_arr, n);
 
    printf("Sorted array:\n");
    for (int i = 0; i < n; i++)
        printf("%d ", h_arr[i]);
    printf("\n");
 
    free(h_arr);
    return 0;
}

/*
nvcc -o a3 a3.cu
./a3
Enter number of elements: 6
Enter 6 elements:
67 98 23 12 45 88
Sorted array:
12 23 45 67 88 98 
*/

Write a program in CUDA which performs convolution operation on one-dimensional input array N of size width using a mask array M of size mask_width to produce the resultant one-dimensional array P of size width.

#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

__global__ void convolution_1D_kernel(float *input, float *mask, float *output, int maskWidth, int inputWidth) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;

    if (i < inputWidth) {
        float result = 0.0f;

        for (int j = 0; j < maskWidth; j++) {
            int inputIndex = i + j - (maskWidth / 2);
            if (inputIndex >= 0 && inputIndex < inputWidth) {
                result += input[inputIndex] * mask[j];
            }
        }
        output[i] = result;
    }}

int main() {
    int inputWidth, maskWidth;

    printf("Enter size of input array: ");
    scanf("%d", &inputWidth);
    printf("Enter size of mask array: ");
    scanf("%d", &maskWidth);

    float *h_input = (float *)malloc(inputWidth * sizeof(float));
    float *h_mask = (float *)malloc(maskWidth * sizeof(float));
    float *h_output = (float *)malloc(inputWidth * sizeof(float));

    printf("Enter elements of input array:\n");
    for (int i = 0; i < inputWidth; i++) {
        scanf("%f", &h_input[i]);
    }

    printf("Enter elements of mask array:\n");
    for (int i = 0; i < maskWidth; i++) {
        scanf("%f", &h_mask[i]);
    }

    float *d_input, *d_mask, *d_output;
    cudaMalloc((void **)&d_input, inputWidth * sizeof(float));
    cudaMalloc((void **)&d_mask, maskWidth * sizeof(float));
    cudaMalloc((void **)&d_output, inputWidth * sizeof(float));

    cudaMemcpy(d_input, h_input, inputWidth * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_mask, h_mask, maskWidth * sizeof(float), cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocksPerGrid = (inputWidth + threadsPerBlock - 1) / threadsPerBlock;
    convolution_1D_kernel<<<blocksPerGrid, threadsPerBlock>>>(d_input, d_mask, d_output, maskWidth, inputWidth);

    cudaMemcpy(h_output, d_output, inputWidth * sizeof(float), cudaMemcpyDeviceToHost);

    printf("\nConvolution result: ");
    for (int i = 0; i < inputWidth; i++) {
        printf("%.2f ", h_output[i]);
    }
    printf("\n");

    cudaFree(d_input);
    cudaFree(d_mask);
    cudaFree(d_output);
    free(h_input);
    free(h_mask);
    free(h_output);

    return 0;
}

/*Enter size of input array: 8
Enter size of mask array: 3
Enter elements of input array:
2 5 3 1 7 4 2 9
Enter elements of mask array:
0.5 1.0 0.5

Convolution result: 4.50 7.50 6.00 6.00 9.50 8.50 8.50 10.00
*/


/*write a program in CUDA to count the number of times a given word is repeated in a sentence.(use atomic function).*/

#include <stdio.h>
#include <string.h>
#include <cuda.h>
 
#define MAX_WORDS 256
#define WORD_LEN 20
 
__device__ int compareWords(const char *word1, const char *word2) {
    while (*word1 && *word2 && (*word1 == *word2)) {
        word1++;
        word2++;
    }
    return (*word1 == '\0' && *word2 == '\0');
}
 
__global__ void countOccurrences(char *d_text, char *d_word, int *d_count, int wordCount) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < wordCount) {
        if (compareWords(&d_text[idx * WORD_LEN], d_word)) {
            atomicAdd(d_count, 1);  
        }
    }
}
 
int main() {
    char h_text[MAX_WORDS][WORD_LEN]; 
    char h_word[WORD_LEN];  
    int h_count = 0, wordCount;

    printf("Enter number of words: ");
    scanf("%d", &wordCount);
    printf("Enter the sentence (word by word):\n");
    for (int i = 0; i < wordCount; i++) {
        scanf("%s", h_text[i]);
    }
    printf("Enter the word to search: ");
    scanf("%s", h_word);
 
    char *d_text, *d_word;
    int *d_count;
    cudaMalloc(&d_text, MAX_WORDS * WORD_LEN * sizeof(char));
    cudaMalloc(&d_word, WORD_LEN * sizeof(char));
    cudaMalloc(&d_count, sizeof(int));

    cudaMemcpy(d_text, h_text, MAX_WORDS * WORD_LEN * sizeof(char), cudaMemcpyHostToDevice);
    cudaMemcpy(d_word, h_word, WORD_LEN * sizeof(char), cudaMemcpyHostToDevice);
    cudaMemcpy(d_count, &h_count, sizeof(int), cudaMemcpyHostToDevice);
 
    int blockSize = 256;
    int gridSize = (wordCount + blockSize - 1) / blockSize;
    countOccurrences<<<gridSize, blockSize>>>(d_text, d_word, d_count, wordCount);
    cudaDeviceSynchronize();
 
    cudaMemcpy(&h_count, d_count, sizeof(int), cudaMemcpyDeviceToHost);
 
    printf("Word '%s' found %d times.\n", h_word, h_count);

    cudaFree(d_text);
    cudaFree(d_word);
    cudaFree(d_count);
 
    return 0;
}


/*Write a program in CUDA to perform selection sort in parallel.*/

#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

__global__ void selection_sort_kernel(float *d_arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (d_arr[j] < d_arr[min_idx]) {
                min_idx = j;
            }
        }
        if (min_idx != i) {
            float temp = d_arr[i];
            d_arr[i] = d_arr[min_idx];
            d_arr[min_idx] = temp;
        }}}

int main() {
    int n;

    printf("Enter number of elements: ");
    scanf("%d", &n);

    float *h_arr = (float *)malloc(n * sizeof(float));
    if (h_arr == NULL) {
        fprintf(stderr, "Failed to allocate host memory\n");
        return -1;
    }

    printf("Enter elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%f", &h_arr[i]);
    }

    float *d_arr;
    cudaMalloc((void **)&d_arr, n * sizeof(float));
    cudaMemcpy(d_arr, h_arr, n * sizeof(float), cudaMemcpyHostToDevice);

    selection_sort_kernel<<<1, 1>>>(d_arr, n);

    cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        fprintf(stderr, "Kernel launch failed: %s\n", cudaGetErrorString(err));
        goto cleanup;
    }

    cudaMemcpy(h_arr, d_arr, n * sizeof(float), cudaMemcpyDeviceToHost);

    printf("\nSorted array: ");
    for (int i = 0; i < n; i++) {
        printf("%.2f ", h_arr[i]);
    }
    printf("\n");

cleanup:
    cudaFree(d_arr);
    free(h_arr);

    return 0;
}

/*
Enter the number of elements: 6
Enter the elements of the array:
87 54 76 12 43 2

Sorted array: 2.00 12.00 43.00 54.00 76.00 87.00
*/


/*
nvcc -o q1 q1.cu
./q1
Enter number of words: 6
Enter the sentence (word by word):
cuda is fast cuda cuda parallel
Enter the word to search: cuda
Word 'cuda' found 3 times.
*/


/*Write a CUDA program which takes N binary numbers as input and stores the one's complement of each element in another array in parallel.*/

#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

__global__ void onesComplement(int *input, int *output, int N) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        output[idx] = 1 - input[idx];
    }
}

int main() {
    int N;

    printf("Enter number of binary numbers: ");
    scanf("%d", &N);

    int *h_input = (int *)malloc(N * sizeof(int));
    int *h_output = (int *)malloc(N * sizeof(int));

    printf("Enter binary numbers (0s and 1s only):\n");
    for (int i = 0; i < N; i++) {
        scanf("%d", &h_input[i]);
        if (h_input[i] != 0 && h_input[i] != 1) {
            printf("Invalid input. Please enter binary numbers (0 or 1).\n");
            free(h_input);
            free(h_output);
            return -1;
        }
    }

    int *d_input, *d_output;
    cudaMalloc((void **)&d_input, N * sizeof(int));
    cudaMalloc((void **)&d_output, N * sizeof(int));

    cudaMemcpy(d_input, h_input, N * sizeof(int), cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocksPerGrid = (N + threadsPerBlock - 1) / threadsPerBlock;
    onesComplement<<<blocksPerGrid, threadsPerBlock>>>(d_input, d_output, N);

    cudaMemcpy(h_output, d_output, N * sizeof(int), cudaMemcpyDeviceToHost);

    printf("\nOne's complement results:\n");
    for (int i = 0; i < N; i++) {
        printf("One's complement of %d is %d\n", h_input[i], h_output[i]);
    }

    cudaFree(d_input);
    cudaFree(d_output);

    free(h_input);
    free(h_output);

    return 0;
}

/*
Enter the number of binary numbers: 5
Enter the binary numbers (0s and 1s only):
1
0
1
1
0

One's complement results:
One's complement of 1 is 0
One's complement of 0 is 1
One's complement of 1 is 0
One's complement of 1 is 0
One's complement of 0 is 1
*/

/*Write a program in CUDA which takes N integers as input. It converts these integers into their corresponding octal values and stores the result in another array in parallel.*/

#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

__device__ void intToOctal(int num, char *octal) {
    int index = 0;
    do {
        octal[index++] = (num % 8) + '0';
        num /= 8;
    } while (num > 0);
    octal[index] = '\0'; 

    for (int i = 0; i < index / 2; i++) {
        char temp = octal[i];
        octal[i] = octal[index - 1 - i];
        octal[index - 1 - i] = temp;
    }
}

__global__ void convertToOctal(int *input, char *output, int N) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N) {
        intToOctal(input[idx], &output[idx * 12]); 
    }
}

int main() {
    int N;

    printf("Enter number of integers: ");
    scanf("%d", &N);

    int *h_input = (int *)malloc(N * sizeof(int));
    char *h_output = (char *)malloc(N * 12 * sizeof(char)); 

    printf("Enter integers:\n");
    for (int i = 0; i < N; i++) {
        scanf("%d", &h_input[i]);
    }

    int *d_input;
    char *d_output;
    cudaMalloc((void **)&d_input, N * sizeof(int));
    cudaMalloc((void **)&d_output, N * 12 * sizeof(char)); 

    cudaMemcpy(d_input, h_input, N * sizeof(int), cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocksPerGrid = (N + threadsPerBlock - 1) / threadsPerBlock;
    convertToOctal<<<blocksPerGrid, threadsPerBlock>>>(d_input, d_output, N);

    cudaMemcpy(h_output, d_output, N * 12 * sizeof(char), cudaMemcpyDeviceToHost);

    printf("\nOctal values:\n");
    for (int i = 0; i < N; i++) {
        printf("%d in octal is %s\n", h_input[i], &h_output[i * 12]);
    }

    cudaFree(d_input);
    cudaFree(d_output);

    free(h_input);
    free(h_output);

    return 0;
}

/*
Enter number of integers: 3
Enter integers:
10 15 8

Octal values:
10 in octal is 12
15 in octal is 17
8 in octal is 10
*/


/*write a CUDA program that reads a string S and produces the string RS as follows:
Input string S: PCAP Output string RS: PCAPPCAPCP*/

#include <stdio.h>
#include <cuda.h>
#include <string.h>
 
#define MAX_LEN 256
 
__global__ void generateRS(char *d_S, char *d_RS, int len) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
 
    if (idx < (len * (len + 1)) / 2) {
        int row = 0, pos = idx;
        while (pos >= len - row) {
            pos -= (len - row);
            row++;
        }
        d_RS[idx] = d_S[pos]; 
    }}
 
int main() {
    char h_S[MAX_LEN], h_RS[MAX_LEN * MAX_LEN];
    int len;
 
    printf("Enter the input string S: ");
    scanf("%s", h_S);
    len = strlen(h_S);
 
    int RS_len = (len * (len + 1)) / 2;
 
    char *d_S, *d_RS;
    cudaMalloc((void **)&d_S, len * sizeof(char));
    cudaMalloc((void **)&d_RS, RS_len * sizeof(char));
 
    cudaMemcpy(d_S, h_S, len * sizeof(char), cudaMemcpyHostToDevice);

    int blockSize = 256;
    int gridSize = (RS_len + blockSize - 1) / blockSize;
    generateRS<<<gridSize, blockSize>>>(d_S, d_RS, len);

    cudaMemcpy(h_RS, d_RS, RS_len * sizeof(char), cudaMemcpyDeviceToHost);
    h_RS[RS_len] = '\0'; 
 
    printf("Output string RS: %s\n", h_RS);
 
    cudaFree(d_S);
    cudaFree(d_RS);
 
    return 0;
}

/*
nvcc -o q2 q2.cu
./q2
Enter the input string S: PCAP
Output string RS: PCAPPCAPCP
*/

/*cuda program which takes a string as input and determines the number of occurences of a character 'a' in the string. this program uses atomicAdd() function.*/

#include <stdio.h>
#include <string.h>
#include <cuda.h>

__global__ void countOccurrences(char *input, int *count, int length) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < length) {
        if (input[idx] == 'a') {
            atomicAdd(count, 1);
        }
    }
}

int main() {
    char input[1024];
    int count = 0;
    int *d_count;
    char *d_input;

    printf("Enter a string: ");
    fgets(input, sizeof(input), stdin);
    input[strcspn(input, "\n")] = 0; 

    int length = strlen(input);

    cudaMalloc((void**)&d_count, sizeof(int));
    cudaMalloc((void**)&d_input, length + 1); 

    cudaMemcpy(d_count, &count, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_input, input, length + 1, cudaMemcpyHostToDevice); // +1 for null terminator

    int blockSize = 256;
    int numBlocks = (length + blockSize - 1) / blockSize;
    countOccurrences<<<numBlocks, blockSize>>>(d_input, d_count, length);

    cudaMemcpy(&count, d_count, sizeof(int), cudaMemcpyDeviceToHost);

    cudaFree(d_count);
    cudaFree(d_input);

    printf("Number of occurrences of 'a': %d\n", count);
    return 0;
}

/*
nvcc -o sample sample.cu
./sample
Enter a string: cuda is amazing and awesome
Number of occurrences of 'a': 5
*/


/*write a CUDA program which reads a string consisting of N words and reverse each word of it in parallel.*/

#include <stdio.h>
#include <string.h>
#include <cuda.h>

__global__ void reverseStringKernel(char *input, char *output, int length) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < length) {
        output[idx] = input[length - 1 - idx];
    }
}

void reverseString(char *input, char *output) {
    int length = strlen(input);

    char *d_input, *d_output;
    cudaMalloc((void**)&d_input, length + 1);
    cudaMalloc((void**)&d_output, length + 1);

    cudaMemcpy(d_input, input, length + 1, cudaMemcpyHostToDevice);

    int blockSize = 256;
    int numBlocks = (length + blockSize - 1) / blockSize;
    reverseStringKernel<<<numBlocks, blockSize>>>(d_input, d_output, length);

    cudaMemcpy(output, d_output, length + 1, cudaMemcpyDeviceToHost);

    cudaFree(d_input);
    cudaFree(d_output);
}

int main() {
    char input[1024];
    char output[1024];

    printf("Enter a string: ");
    fgets(input, sizeof(input), stdin);
    input[strcspn(input, "\n")] = 0; 

    reverseString(input, output);

    printf("Reversed string: %s\n", output);
    return 0;
}

/*
nvcc -o a1 a1.cu
./a1

Enter a string: Cuda is fast
Reversed string: tsaf si aduC
*/


/*write a CUDA program that takes a string Sin as input and one integer value N and produces an output string, Sout, in parallel by concatenating input string Sin, N times as shown below.
Input:  Sin = "Hello"  N = 3
Output: Sout = "HelloHelloHello"
Note: every thread copies the same character from the Input string S, N times to the required position.*/
 
#include <stdio.h>
#include <cuda.h>
#include <string.h>
 
#define MAX_LEN 256  
#define MAX_N 10     
 
__global__ void concatStringKernel(char *d_Sin, char *d_Sout, int len, int N) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
 
    if (idx < len) {
        for (int i = 0; i < N; i++) {
            d_Sout[idx + i * len] = d_Sin[idx];
        }    }}
 
int main() {
    char h_Sin[MAX_LEN], h_Sout[MAX_LEN * MAX_N];
    int N;
 
    printf("Enter a string: ");
    scanf("%s", h_Sin);
    printf("Enter N: ");
    scanf("%d", &N);
 
    int len = strlen(h_Sin);
    int outLen = len * N;
 
    char *d_Sin, *d_Sout;
    cudaMalloc((void**)&d_Sin, len * sizeof(char));
    cudaMalloc((void**)&d_Sout, outLen * sizeof(char));
 
    cudaMemcpy(d_Sin, h_Sin, len * sizeof(char), cudaMemcpyHostToDevice);
 
    int blockSize = 256;
    int gridSize = (len + blockSize - 1) / blockSize;
    concatStringKernel<<<gridSize, blockSize>>>(d_Sin, d_Sout, len, N);
    cudaDeviceSynchronize();
 
    cudaMemcpy(h_Sout, d_Sout, outLen * sizeof(char), cudaMemcpyDeviceToHost);
    h_Sout[outLen] = '\0'; 
 
    printf("Output string: %s\n", h_Sout);
 
    cudaFree(d_Sin);
    cudaFree(d_Sout);
 
    return 0;
}

/*nvcc -o a2 a2.cu
./a2

Enter a string: Hello
Enter N: 3
Output string: HelloHelloHello
*/


/*write a CUDA program which reads a string Sin and produces an output string T as shown below.
Input:   Sin:"Hai"
Output:  T: "Haaiii"*/

#include <stdio.h>
#include <cuda.h>
#include <string.h>
 
#define MAX_LEN 256  
 
__global__ void transformStringKernel(char *d_Sin, char *d_T, int *d_pos, int len) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < len) {
        int start = d_pos[idx];
        for (int j = 0; j < idx + 1; j++) {
            d_T[start + j] = d_Sin[idx]; 
        }    }}
 
int main() {
    char h_Sin[MAX_LEN], h_T[MAX_LEN * MAX_LEN]; 
    printf("Enter a string: ");
    scanf("%s", h_Sin);
 
    int len = strlen(h_Sin), h_pos[MAX_LEN], totalLen = 0;
 
    for (int i = 0; i < len; i++) {
        h_pos[i] = totalLen;
        totalLen += (i + 1);
    }
 
    char *d_Sin, *d_T;
    int *d_pos;
    cudaMalloc(&d_Sin, len * sizeof(char));
    cudaMalloc(&d_T, totalLen * sizeof(char));
    cudaMalloc(&d_pos, len * sizeof(int));
 
    cudaMemcpy(d_Sin, h_Sin, len * sizeof(char), cudaMemcpyHostToDevice);
    cudaMemcpy(d_pos, h_pos, len * sizeof(int), cudaMemcpyHostToDevice);

    transformStringKernel<<<1, len>>>(d_Sin, d_T, d_pos, len);
    cudaDeviceSynchronize();
 
    cudaMemcpy(h_T, d_T, totalLen * sizeof(char), cudaMemcpyDeviceToHost);
    h_T[totalLen] = '\0';
 
    printf("Output string: %s\n", h_T);
 
    cudaFree(d_Sin);
    cudaFree(d_T);
    cudaFree(d_pos);
 
    return 0;
}

/*nvcc -o a3 a3.cu
./a3

Enter a string: Hai
Output string: Haaiii
*/

Write a program in CUDA to add two Matrices for the following specifications(combined):
a. Each row of resultant matrix to be computed by one thread.
b. Each column of resultant matrix to be computed by one thread.
c. Each element of resultant matrix to be computed by one thread.

#include <cuda_runtime.h>
#include <stdio.h>


__global__ void addRows(float *A, float *B, float *C, int n) {
    int row = blockIdx.x; 
    for (int col = 0; col < n; col++) {
        C[row * n + col] = A[row * n + col] + B[row * n + col];
    }
}

__global__ void addColumns(float *A, float *B, float *C, int n) {
    int col = blockIdx.x; 
    for (int row = 0; row < n; row++) {
        C[row * n + col] = A[row * n + col] + B[row * n + col];
    }
}

__global__ void addElements(float *A, float *B, float *C, int n) {
    int row = blockIdx.x; 
    int col = threadIdx.x;
    C[row * n + col] = A[row * n + col] + B[row * n + col];
}

int main() {
    int n, choice;

    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    do {
        printf("\n1. Row-wise\n");
        printf("2. Column-wise\n");
        printf("3. Element-wise\n");
        printf("4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        if (choice == 1) {
            printf("\nRow-Wise\n");
            addRows<<<n, 1>>>(d_A, d_B, d_C, n);
            
        } else if (choice == 2) {
            printf("\nColumn-Wise\n");
            addColumns<<<n, 1>>>(d_A, d_B, d_C, n);
        } else if (choice == 3) {
            printf("\nElement-Wise\n");
            addElements<<<n, n>>>(d_A, d_B, d_C, n);
        } else if (choice == 4) {
            printf("Exited\n");
            break;
        } else {
            printf("Invalid\n");
            continue;
        }

        cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

        printf("Resultant Matrix:\n");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                printf("%.2f ", h_C[i * n + j]);
            }
            printf("\n");
        }
    } while (choice != 4);

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}


Write a program in CUDA to multiply two Matrices for the following specifications(combined):
a. Each row of resultant matrix to be computed by one thread.
b. Each column of resultant matrix to be computed by one thread. 
c. Each element of resultant matrix to be computed by one thread.

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void multiplyRows(float *A, float *B, float *C, int n) {
    int row = blockIdx.x;
    for (int col = 0; col < n; col++) {
        float sum = 0.0;
        for (int k = 0; k < n; k++) {
            sum += A[row * n + k] * B[k * n + col];
        }
        C[row * n + col] = sum;
    }
}

__global__ void multiplyColumns(float *A, float *B, float *C, int n) {
    int col = blockIdx.x;
    for (int row = 0; row < n; row++) {
        float sum = 0.0;
        for (int k = 0; k < n; k++) {
            sum += A[row * n + k] * B[k * n + col];
        }
        C[row * n + col] = sum;
    }
}

__global__ void multiplyElements(float *A, float *B, float *C, int n) {
    int row = blockIdx.x;
    int col = threadIdx.x;
    float sum = 0.0;
    for (int k = 0; k < n; k++) {
        sum += A[row * n + k] * B[k * n + col];
    }
    C[row * n + col] = sum;
}

int main() {
    int n, choice;

    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    do {
        printf("\n1. Row-wise\n");
        printf("2. Column-wise\n");
        printf("3. Element-wise\n");
        printf("4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        if (choice == 1) {
            printf("\nRow-Wise Multiplication\n");
            multiplyRows<<<n, 1>>>(d_A, d_B, d_C, n);
        } else if (choice == 2) {
            printf("\nColumn-Wise Multiplication\n");
            multiplyColumns<<<n, 1>>>(d_A, d_B, d_C, n);
        } else if (choice == 3) {
            printf("\nElement-Wise Multiplication\n");
            multiplyElements<<<n, n>>>(d_A, d_B, d_C, n);
        } else if (choice == 4) {
            printf("Exited\n");
            break;
        } else {
            printf("Invalid choice\n");
            continue;
        }

        cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

        printf("Resultant Matrix:\n");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                printf("%.2f ", h_C[i * n + j]);
            }
            printf("\n");
        }
    } while (choice != 4);

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}

Write a program in CUDA to add two Matrices for the following specifications Each row of resultant matrix to be computed by one thread.(row major)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void addRows(float *A, float *B, float *C, int n) {
    int row = blockIdx.x;
    for (int col = 0; col < n; col++) {
        C[row * n + col] = A[row * n + col] + B[row * n + col];
    }}

int main() {
    int n;
    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    addRows<<<n, 1>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);

    return 0;
}


Write a program in CUDA to add two Matrices for the following specifications: Each column of resultant matrix to be computed by one thread.(column major)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void addColumns(float *A, float *B, float *C, int n) {
    int col = threadIdx.x; 
    for (int row = 0; row < n; row++) {
        C[row * n + col] = A[row * n + col] + B[row * n + col];
    }
}

int main() {
    int n;
    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    addColumns<<<1, n>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);

    return 0;
}


Write a program in CUDA to add two Matrices for the following specifications: Each element of resultant matrix to be computed by one thread.(element wise)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void addElements(float *A, float *B, float *C, int n) {
    int row = blockIdx.x;  
    int col = threadIdx.x;
    C[row * n + col] = A[row * n + col] + B[row * n + col];
}

int main() {
    int n;
    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    addElements<<<n, n>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }
    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);

    return 0;
}

Write a program in CUDA to multiply two Matrices for the following specifications: Each row of resultant matrix to be computed by one thread.(row major)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void multiplyRows(float *A, float *B, float *C, int n) {
    int row = threadIdx.x; 
    if (row < n) {
        for (int col = 0; col < n; col++) {
            float sum = 0.0;
            for (int k = 0; k < n; k++) {
                sum += A[row * n + k] * B[k * n + col];
            }
            C[row * n + col] = sum;
        }
    }}

int main() {
    int n;

    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    printf("\nRow-Wise Multiplication using one thread per row\n");
    multiplyRows<<<1, n>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}

Write a program in CUDA to multiply two Matrices for the following specifications: Each column of resultant matrix to be computed by one thread.(column major)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void multiplyColumns(float *A, float *B, float *C, int n) {
    int col = threadIdx.x; 
    if (col < n) {
        for (int row = 0; row < n; row++) {
            float sum = 0.0;
            for (int k = 0; k < n; k++) {
                sum += A[row * n + k] * B[k * n + col];
            }
            C[row * n + col] = sum;
        }
    }
}

int main() {
    int n;

    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    multiplyColumns<<<1, n>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}


Write a program in CUDA to multiply two Matrices for the following specifications:Each element of resultant matrix to be computed by one thread.(element wise)

#include <cuda_runtime.h>
#include <stdio.h>

__global__ void multiplyElements(float *A, float *B, float *C, int n) {
    int row = blockIdx.x;  
    int col = threadIdx.x; 
    if (row < n && col < n) {
        float sum = 0.0;
        for (int k = 0; k < n; k++) {
            sum += A[row * n + k] * B[k * n + col];
        }
        C[row * n + col] = sum;
    }
}

int main() {
    int n;

    printf("Enter matrix size (n x n): ");
    scanf("%d", &n);

    size_t size = n * n * sizeof(float);
    float *h_A = (float *)malloc(size);
    float *h_B = (float *)malloc(size);
    float *h_C = (float *)malloc(size);

    printf("Enter elements of matrix A:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_A[i]);

    printf("Enter elements of matrix B:\n");
    for (int i = 0; i < n * n; i++) scanf("%f", &h_B[i]);

    float *d_A, *d_B, *d_C;
    cudaMalloc((void **)&d_A, size);
    cudaMalloc((void **)&d_B, size);
    cudaMalloc((void **)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    printf("\nElement-Wise Multiplication using one thread per element\n");
    multiplyElements<<<n, n>>>(d_A, d_B, d_C, n); // n blocks and n threads per block

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Resultant Matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%.2f ", h_C[i * n + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}


Write a CUDA program that reads a MXN matrix A and produces a resultant matrix B of same size as follows: Replace all the even numbered matrix elements with their row sum and odd numbered matrix elements with their column sum.

#include <stdio.h>
#include <cuda.h>


__global__ void processMatrix(int *A, int *B, int *rowSum, int *colSum, int rows, int cols) {
    int row = blockIdx.x;
    int col = threadIdx.x;

    if (row < rows && col < cols) {
        int val = A[row * cols + col];
        if (val % 2 == 0) {
            B[row * cols + col] = rowSum[row];
        } else {
            B[row * cols + col] = colSum[col];
        }
    }
}

int main() {
    int rows, cols;

    printf("Enter the number of rows: ");
    scanf("%d", &rows);
    printf("Enter the number of columns: ");
    scanf("%d", &cols);

    int *A = (int *)malloc(rows * cols * sizeof(int));
    int *B = (int *)malloc(rows * cols * sizeof(int));
    int *rowSum = (int *)malloc(rows * sizeof(int));
    int *colSum = (int *)malloc(cols * sizeof(int));

    for (int i = 0; i < rows; i++) rowSum[i] = 0;
    for (int j = 0; j < cols; j++) colSum[j] = 0;

    printf("Enter the elements of the matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &A[i * cols + j]);
            rowSum[i] += A[i * cols + j];
            colSum[j] += A[i * cols + j];
        }
    }

    int *d_A, *d_B, *d_rowSum, *d_colSum;
    cudaMalloc((void **)&d_A, rows * cols * sizeof(int));
    cudaMalloc((void **)&d_B, rows * cols * sizeof(int));
    cudaMalloc((void **)&d_rowSum, rows * sizeof(int));
    cudaMalloc((void **)&d_colSum, cols * sizeof(int));

    cudaMemcpy(d_A, A, rows * cols * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_rowSum, rowSum, rows * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_colSum, colSum, cols * sizeof(int), cudaMemcpyHostToDevice);

    processMatrix<<<rows, cols>>>(d_A, d_B, d_rowSum, d_colSum, rows, cols);

    cudaMemcpy(B, d_B, rows * cols * sizeof(int), cudaMemcpyDeviceToHost);

    printf("Resultant Matrix B:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", B[i * cols + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_rowSum);
    cudaFree(d_colSum);
    	
    free(A);
    free(B);
    free(rowSum);
    free(colSum);

    return 0;
}

/*
Enter the number of rows: 2
Enter the number of columns: 3
Enter the elements of the matrix:
1 2 3
4 5 6
Resultant Matrix B:
5 6 9 
15 7 15 
*/


Write a CUDA program to read a matrix A of size NXN. It replaces the principal diagonal elements with zero. Elements above the principal diagonal by their factorial and elements below the principal diagonal by their sum of digits.
#include <stdio.h>
#include <stdlib.h>

#define N 3

__global__ void processMatrix(int *A, int n) {
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < n && col < n) {
        if (row == col) {
            A[row * n + col] = 0;
        } else if (row < col) {
            int value = A[row * n + col];
            int factorial = 1;
            for (int i = 1; i <= value; ++i) {
                factorial *= i;
            }
            A[row * n + col] = factorial;
        } else {
            int value = A[row * n + col];
            int sum = 0;
            while (value > 0) {
                sum += value % 10;
                value /= 10;
            }
            A[row * n + col] = sum;
        }
    }
}

void printMatrix(int *A, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%d ", A[i * n + j]);
        }
        printf("\n");
    }
}

int main() {
    int h_A[N * N]; 
    int *d_A;
    size_t size = N * N * sizeof(int);

    printf("Enter the elements of the %dx%d matrix:\n", N, N);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            scanf("%d", &h_A[i * N + j]);
        }
    }

    cudaMalloc((void **)&d_A, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);

    dim3 blockDim(16, 16);
    dim3 gridDim((N + blockDim.x - 1) / blockDim.x, (N + blockDim.y - 1) / blockDim.y);

    processMatrix<<<gridDim, blockDim>>>(d_A, N);

    cudaMemcpy(h_A, d_A, size, cudaMemcpyDeviceToHost);

    printf("Processed Matrix:\n");
    printMatrix(h_A, N);

    cudaFree(d_A);

    return 0;
}

/*
Enter the elements of the 3x3 matrix:
1 2 3
4 5 6
11 12 14
Processed Matrix:
0 2 6 
4 0 720 
2 3 0 
*/


Write a program in CUDA to perform parallel Sparse Matrix - Vector multiplication using com- pressed sparse row (CSR) storage format. Represent the input sparse matrix in CSR format in the host code.

#include <stdio.h>
#include <stdlib.h>
#include <cuda.h>

__global__ void csrSpMV(int *row_ptr, int *col_ind, float *values, float *x, float *y, int num_rows) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < num_rows) {
        float dot_product = 0.0;

        for (int i = row_ptr[row]; i < row_ptr[row + 1]; ++i) {
            dot_product += values[i] * x[col_ind[i]];
        }

        y[row] = dot_product;
    }
}

int main() {
    int num_rows, num_cols, nnz; 

    printf("Enter the number of rows and columns of the matrix:\n");
    scanf("%d %d", &num_rows, &num_cols);
    printf("Enter the number of non-zero elements:\n");
    scanf("%d", &nnz);

    int *h_row_ptr = (int *)malloc((num_rows + 1) * sizeof(int));
    int *h_col_ind = (int *)malloc(nnz * sizeof(int));
    float *h_values = (float *)malloc(nnz * sizeof(float));
    float *h_x = (float *)malloc(num_cols * sizeof(float));
    float *h_y = (float *)malloc(num_rows * sizeof(float));

    printf("Enter the row pointer array (size %d):\n", num_rows + 1);
    for (int i = 0; i < num_rows + 1; ++i) {
        scanf("%d", &h_row_ptr[i]);
    }

    printf("Enter the column index array (size %d):\n", nnz);
    for (int i = 0; i < nnz; ++i) {
        scanf("%d", &h_col_ind[i]);
    }

    printf("Enter the values array (size %d):\n", nnz);
    for (int i = 0; i < nnz; ++i) {
        scanf("%f", &h_values[i]);
    }

    printf("Enter the input vector (size %d):\n", num_cols);
    for (int i = 0; i < num_cols; ++i) {
        scanf("%f", &h_x[i]);
    }

    int *d_row_ptr, *d_col_ind;
    float *d_values, *d_x, *d_y;

    cudaMalloc((void **)&d_row_ptr, (num_rows + 1) * sizeof(int));
    cudaMalloc((void **)&d_col_ind, nnz * sizeof(int));
    cudaMalloc((void **)&d_values, nnz * sizeof(float));
    cudaMalloc((void **)&d_x, num_cols * sizeof(float));
    cudaMalloc((void **)&d_y, num_rows * sizeof(float));

    cudaMemcpy(d_row_ptr, h_row_ptr, (num_rows + 1) * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_col_ind, h_col_ind, nnz * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_values, h_values, nnz * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_x, h_x, num_cols * sizeof(float), cudaMemcpyHostToDevice);

    int block_size = 256;
    int grid_size = (num_rows + block_size - 1) / block_size;

    csrSpMV<<<grid_size, block_size>>>(d_row_ptr, d_col_ind, d_values, d_x, d_y, num_rows);

    cudaMemcpy(h_y, d_y, num_rows * sizeof(float), cudaMemcpyDeviceToHost);

    printf("Resultant vector:\n");
    for (int i = 0; i < num_rows; ++i) {
        printf("%f\n", h_y[i]);
    }

    cudaFree(d_row_ptr);
    cudaFree(d_col_ind);
    cudaFree(d_values);
    cudaFree(d_x);
    cudaFree(d_y);

    free(h_row_ptr);
    free(h_col_ind);
    free(h_values);
    free(h_x);
    free(h_y);

    return 0;
}

/*
Enter the number of rows and columns of the matrix:
3 3
Enter the number of non-zero elements:
5
Enter the row pointer array (size 4):
0 2 3 5
Enter the column index array (size 5):
0 2 1 0 2
Enter the values array (size 5):
4 8 5 3 6
Enter the input vector (size 3):
1 2 3
Resultant vector:
28.000000
10.000000
21.000000
*/


Write a program in CUDA to read MXN matrix A and replace 1st row of this matrix by same elements, 2nd row elements by square of each element and 3rd row elements by cube of each element and so on.

#include <stdio.h>
#include <cuda.h>

__global__ void transformMatrix(int *A, int M, int N) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;
    int col = threadIdx.y;                        

    if (row < M && col < N) {
        int factor = row + 1;                     
        int value = A[row * N + col];               

        int result = 1;                           
        for (int i = 0; i < factor; ++i) {
            result *= value;                       
        }

        A[row * N + col] = result;                  
    }
}

int main() {
    int M, N;

    printf("Enter the number of rows (M) and columns (N) of the matrix:\n");
    scanf("%d %d", &M, &N);

    size_t size = M * N * sizeof(int);
    int *h_A = (int *)malloc(size);

    printf("Enter the elements of the %dx%d matrix:\n", M, N);
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            scanf("%d", &h_A[i * N + j]);
        }
    }

    int *d_A; 
    cudaMalloc((void **)&d_A, size); 

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);

    dim3 blockDim(M, N); 
    dim3 gridDim(1);   

    transformMatrix<<<gridDim, blockDim>>>(d_A, M, N);

    cudaMemcpy(h_A, d_A, size, cudaMemcpyDeviceToHost);

    printf("Transformed Matrix:\n");
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            printf("%d ", h_A[i * N + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);

    free(h_A);
    return 0;
}

/*
Enter the number of rows (M) and columns (N) of the matrix:
3 3
Enter the elements of the 3x3 matrix:
1 2 3 
4 5 6
7 8 9
Transformed Matrix:
1 2 3 
16 25 36 
343 512 729 
*/


Write a CUDA program that reads a matrix A of size MXN and produce an output matrix B of same size such that it replaces all the non-border elements (numbers in bold) of A with its equivalent 1's complement and remaining elements same as matrix A.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CELL_WIDTH 8  

void get_ones_complement_str(int num, char *out) {
    int bits[32], count = 0;

    while (num > 0) {
        bits[count++] = num % 2;
        num /= 2;
    }

    if (count == 0) {  
        strcpy(out, "1");
        return;
    }

    int idx = 0;
    for (int i = count - 1; i >= 0; i--) {
        out[idx++] = bits[i] ? '0' : '1';
    }
    out[idx] = '\0';
}

int main() {
    int m, n;

    printf("Enter number of rows (M): ");
    scanf("%d", &m);
    printf("Enter number of columns (N): ");
    scanf("%d", &n);

    int **A = (int **)malloc(m * sizeof(int *));
    for (int i = 0; i < m; i++)
        A[i] = (int *)malloc(n * sizeof(int));

    printf("Enter elements of matrix A (%dx%d):\n", m, n);
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &A[i][j]);

    printf("\nOutput matrix B:\n");
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {
                printf("%*d", CELL_WIDTH, A[i][j]);
            } else {
                char bin[33];
                get_ones_complement_str(A[i][j], bin);
                int len = strlen(bin);

                for (int s = 0; s < CELL_WIDTH - len; s++) printf(" ");
                printf("%s", bin);
            }
        }
        printf("\n");
    }

    for (int i = 0; i < m; i++) free(A[i]);
    free(A);

    return 0;
}

/*
Enter number of rows (M): 4
Enter number of columns (N): 4
Enter elements of matrix A (4x4):
1 2 3 4
6 5 8 3
2 4 10 1
9 1 2 5

Output matrix B:
       1       2       3       4
       6     010    0111       3
       2     011    0101       1
       9       1       2       5
*/



Write a CUDA program which reads an input matrix A of size MXN and produces an output matrix B of size MXN such that, each element of the output matrix is calculated in parallel. Each element, B[i][j], in the output matrix is obtained by adding the elements in ith row and jth column of the input matrix A.

#include <stdio.h>
#include <cuda.h>
__global__ void computeOutputMatrix(int *A, int *B, int M, int N, int *row_sums, int *col_sums) {
    int row = blockIdx.x * blockDim.x + threadIdx.x; 
    int col = blockIdx.y * blockDim.y + threadIdx.y; 

    if (row < M && col < N) {
        B[row * N + col] = row_sums[row] + col_sums[col]; 
    }
}

__global__ void computeRowSums(int *A, int *row_sums, int M, int N) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < M) {
        int sum = 0;
        for (int col = 0; col < N; ++col) {
            sum += A[row * N + col]; 
        }
        row_sums[row] = sum;
    }
}

__global__ void computeColSums(int *A, int *col_sums, int M, int N) {
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    if (col < N) {
        int sum = 0;
        for (int row = 0; row < M; ++row) {
            sum += A[row * N + col]; 
        }
        col_sums[col] = sum;
    }
}

int main() {
    int M, N;

    printf("Enter the number of rows (M) and columns (N) of the matrix:\n");
    scanf("%d %d", &M, &N);

    size_t matrix_size = M * N * sizeof(int);
    int *h_A = (int *)malloc(matrix_size);
    int *h_B = (int *)malloc(matrix_size);

    int *d_A, *d_B, *d_row_sums, *d_col_sums;

    cudaMalloc((void **)&d_A, matrix_size);
    cudaMalloc((void **)&d_B, matrix_size);
    cudaMalloc((void **)&d_row_sums, M * sizeof(int));
    cudaMalloc((void **)&d_col_sums, N * sizeof(int));

    printf("Enter the elements of the %dx%d matrix:\n", M, N);
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            scanf("%d", &h_A[i * N + j]);
        }
    }

    cudaMemcpy(d_A, h_A, matrix_size, cudaMemcpyHostToDevice);

    dim3 blockDim_row(256);
    dim3 gridDim_row((M + blockDim_row.x - 1) / blockDim_row.x);

    dim3 blockDim_col(256);
    dim3 gridDim_col((N + blockDim_col.x - 1) / blockDim_col.x);

    dim3 blockDim(16, 16);
    dim3 gridDim((M + blockDim.x - 1) / blockDim.x, (N + blockDim.y - 1) / blockDim.y);

    computeRowSums<<<gridDim_row, blockDim_row>>>(d_A, d_row_sums, M, N);
    computeColSums<<<gridDim_col, blockDim_col>>>(d_A, d_col_sums, M, N);

    computeOutputMatrix<<<gridDim, blockDim>>>(d_A, d_B, M, N, d_row_sums, d_col_sums);

    cudaMemcpy(h_B, d_B, matrix_size, cudaMemcpyDeviceToHost);

    printf("Output Matrix:\n");
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            printf("%d ", h_B[i * N + j]);
        }
        printf("\n");
    }

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_row_sums);
    cudaFree(d_col_sums);

    free(h_A);
    free(h_B);
    return 0;
}

/*
Enter the number of rows (M) and columns (N) of the matrix:
2 3
Enter the elements of the 2x3 matrix:
1 2 3
4 5 6
Output Matrix:
11 13 15 
20 22 24 
*/


Write a CUDA program that reads a character type matrix A and integer type matrix B of size MXN. It produces an output string STR such that, every character of A is repeated r times (where r is the integer value in matrix B which is having the same index as that of the character taken in A). Write the kernel such that every value of input matrix must be produced required number of times by one thread.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 1000

__global__ void repeatCharsKernel(char *A, int *B, char *output, int *offsets, int totalSize) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx >= totalSize) return;

    char ch = A[idx];
    int repeat = B[idx];
    int offset = offsets[idx];

    for (int i = 0; i < repeat; i++) {
        output[offset + i] = ch;
    }
}

void computeOffsets(int *B, int *offsets, int totalSize) {
    offsets[0] = 0;
    for (int i = 1; i < totalSize; i++) {
        offsets[i] = offsets[i - 1] + B[i - 1];
    }
}

int main() {
    int M, N;
    printf("Enter dimensions M and N: ");
    scanf("%d %d", &M, &N);
    int totalSize = M * N;

    char *A = (char *)malloc(totalSize * sizeof(char));
    int *B = (int *)malloc(totalSize * sizeof(int));
    int *offsets = (int *)malloc(totalSize * sizeof(int));

    printf("Enter character matrix A:\n");
    for (int i = 0; i < totalSize; i++) {
        scanf(" %c", &A[i]);  
    }

    printf("Enter integer matrix B:\n");
    for (int i = 0; i < totalSize; i++) {
        scanf("%d", &B[i]);
    }

    computeOffsets(B, offsets, totalSize);
    int outputLen = offsets[totalSize - 1] + B[totalSize - 1];

    char *d_A, *d_output;
    int *d_B, *d_offsets;

    cudaMalloc((void **)&d_A, totalSize * sizeof(char));
    cudaMalloc((void **)&d_B, totalSize * sizeof(int));
    cudaMalloc((void **)&d_offsets, totalSize * sizeof(int));
    cudaMalloc((void **)&d_output, outputLen * sizeof(char));

    cudaMemcpy(d_A, A, totalSize * sizeof(char), cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, B, totalSize * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_offsets, offsets, totalSize * sizeof(int), cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocksPerGrid = (totalSize + threadsPerBlock - 1) / threadsPerBlock;
    repeatCharsKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_B, d_output, d_offsets, totalSize);

    char *outputStr = (char *)malloc((outputLen + 1) * sizeof(char));
    cudaMemcpy(outputStr, d_output, outputLen * sizeof(char), cudaMemcpyDeviceToHost);
    outputStr[outputLen] = '\0';

    printf("Output String STR: %s\n", outputStr);

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_offsets);
    cudaFree(d_output);
    free(A);
    free(B);
    free(offsets);
    free(outputStr);

    return 0;
}

/*
Enter dimensions M and N: 2 4
Enter character matrix A:
p C a P
e X a M
Enter integer matrix B:
1 2 4 3
2 4 3 2
Output String STR: pCCaaaaPPPeeXXXXaaaMM
*/


Write a program in CUDA to perform matrix multiplication using 2D Grid and 2D Block.

#include <stdio.h>
#include <stdlib.h>

#define BLOCK_SIZE 16

__global__ void matrixMulKernel(float* A, float* B, float* C, int n) {
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    float sum = 0.0f;

    if (row < n && col < n) {
        for (int k = 0; k < n; ++k) {
            sum += A[row * n + k] * B[k * n + col];
        }
        C[row * n + col] = sum;
    }
}

void printMatrix(float* mat, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%.2f ", mat[i * n + j]);
        }
        printf("\n");
    }
}

int main() {
    int n;
    printf("Enter the size of the matrix (N x N): ");
    scanf("%d", &n);

    int size = n * n * sizeof(float);

    float *h_A = (float*)malloc(size);
    float *h_B = (float*)malloc(size);
    float *h_C = (float*)malloc(size);

    printf("Enter elements of Matrix A (%d x %d):\n", n, n);
    for (int i = 0; i < n * n; ++i) {
        scanf("%f", &h_A[i]);
    }

    printf("Enter elements of Matrix B (%d x %d):\n", n, n);
    for (int i = 0; i < n * n; ++i) {
        scanf("%f", &h_B[i]);
    }

    float *d_A, *d_B, *d_C;

    cudaMalloc((void**)&d_A, size);
    cudaMalloc((void**)&d_B, size);
    cudaMalloc((void**)&d_C, size);

    cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

    dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE);
    dim3 dimGrid((n + BLOCK_SIZE - 1) / BLOCK_SIZE, (n + BLOCK_SIZE - 1) / BLOCK_SIZE);

    matrixMulKernel<<<dimGrid, dimBlock>>>(d_A, d_B, d_C, n);

    cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

    printf("Result Matrix C (A x B):\n");
    printMatrix(h_C, n);

    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_C);
    free(h_A);
    free(h_B);
    free(h_C);
    return 0;
}

/*
Enter the size of the matrix (N x N): 4
Enter elements of Matrix A (4 x 4):
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
Enter elements of Matrix B (4 x 4):
1 0 0 1
0 1 1 0
1 0 1 1
0 1 0 1
Result Matrix C (A x B):
4.00 6.00 5.00 8.00 
12.00 14.00 13.00 20.00 
20.00 22.00 21.00 32.00 
28.00 30.00 29.00 44.00 
*/

Write a program in CUDA to improve the performance of 1D parallel convolution using constant Memory.

#include <stdio.h>
#include <stdlib.h>

#define MAX_FILTER_SIZE 64 

__constant__ float d_Filter[MAX_FILTER_SIZE];

__global__ void conv1D(float* d_Input, float* d_Output, int inputSize, int filterSize) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    float result = 0.0f;

    if (i < inputSize - filterSize + 1) {
        for (int j = 0; j < filterSize; ++j) {
            result += d_Input[i + j] * d_Filter[j];
        }
        d_Output[i] = result;
    }
}

void printArray(float* arr, int size) {
    for (int i = 0; i < size; ++i) {
        printf("%.2f ", arr[i]);
    }
    printf("\n");
}

int main() {
    int inputSize, filterSize;

    printf("Enter size of input array: ");
    scanf("%d", &inputSize);

    float *h_Input = (float*)malloc(inputSize * sizeof(float));
    printf("Enter %d elements of input array:\n", inputSize);
    for (int i = 0; i < inputSize; ++i) {
        scanf("%f", &h_Input[i]);
    }

    printf("Enter size of filter: ");
    scanf("%d", &filterSize);

    if (filterSize > MAX_FILTER_SIZE || filterSize > inputSize) {
        printf("Error\n");
        return 1;
    }

    float h_Filter[MAX_FILTER_SIZE];
    printf("Enter %d elements of filter:\n", filterSize);
    for (int i = 0; i < filterSize; ++i) {
        scanf("%f", &h_Filter[i]);
    }

    int outputSize = inputSize - filterSize + 1;

    float *h_Output = (float*)malloc(outputSize * sizeof(float));
    float *d_Input, *d_Output;

    cudaMalloc((void**)&d_Input, inputSize * sizeof(float));
    cudaMalloc((void**)&d_Output, outputSize * sizeof(float));

    cudaMemcpy(d_Input, h_Input, inputSize * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpyToSymbol(d_Filter, h_Filter, filterSize * sizeof(float));

    int threadsPerBlock = 256;
    int blocks = (outputSize + threadsPerBlock - 1) / threadsPerBlock;
    conv1D<<<blocks, threadsPerBlock>>>(d_Input, d_Output, inputSize, filterSize);

    cudaMemcpy(h_Output, d_Output, outputSize * sizeof(float), cudaMemcpyDeviceToHost);

    printf("Output array:\n");
    printArray(h_Output, outputSize);

    cudaFree(d_Input);
    cudaFree(d_Output);
    free(h_Input);
    free(h_Output);

    return 0;
}

/*
Enter size of input array: 7
Enter 7 elements of input array:
10 20 30 40 50 60 70
Enter size of filter (max 64): 3
Enter 3 elements of filter:
2 1 -1
Output array:
10.00 30.00 50.00 70.00 90.00 
*/


Write a program in CUDA to perform inclusive scan algorithm.

#include <stdio.h>
#include <stdlib.h>

#define N 1024  
#define THREADS_PER_BLOCK 1024

__global__ void inclusiveScan(float* d_input, float* d_output, int n) {
    __shared__ float temp[N];

    int tid = threadIdx.x;

    if (tid < n) {
        temp[tid] = d_input[tid];
    }
    __syncthreads();

    for (int offset = 1; offset < n; offset *= 2) {
        float val = 0;
        if (tid >= offset)
            val = temp[tid - offset];
        __syncthreads();
        if (tid >= offset)
            temp[tid] += val;
        __syncthreads();
    }

    if (tid < n) {
        d_output[tid] = temp[tid];
    }
}

void printArray(float* arr, int n) {
    for (int i = 0; i < n; ++i)
        printf("%.2f ", arr[i]);
    printf("\n");
}

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);

    if (n > N) {
        printf("Error");
        return 1;
    }

    float *h_input = (float*)malloc(n * sizeof(float));
    float *h_output = (float*)malloc(n * sizeof(float));

    printf("Enter %d elements:\n", n);
    for (int i = 0; i < n; ++i)
        scanf("%f", &h_input[i]);

    float *d_input, *d_output;
    cudaMalloc((void**)&d_input, n * sizeof(float));
    cudaMalloc((void**)&d_output, n * sizeof(float));

    cudaMemcpy(d_input, h_input, n * sizeof(float), cudaMemcpyHostToDevice);

    inclusiveScan<<<1, THREADS_PER_BLOCK>>>(d_input, d_output, n);

    cudaMemcpy(h_output, d_output, n * sizeof(float), cudaMemcpyDeviceToHost);

    printf("Inclusive scan result:\n");
    printArray(h_output, n);

    cudaFree(d_input);
    cudaFree(d_output);
    free(h_input);
    free(h_output);
    return 0;
}

/*
Enter number of elements: 5
Enter 5 elements:
1 2 3 4 5
Inclusive scan result:
1.00 3.00 6.00 10.00 15.00 
*/

Write a program in CUDA which displays a shopping mall item menu with its price. The N number of friends are allowed to purchase as many items they want. Calculate the total purchase done by N friends.

#include <stdio.h>
#include <cuda.h>

#define MAX_ITEMS 100
#define MAX_FRIENDS 100

__global__ void calculateTotal(int *items, int *purchases, int *friendTotals, int numItems) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < MAX_FRIENDS) {
        int total = 0;
        for (int i = 0; i < numItems; i++) {
            total += purchases[tid * numItems + i] * items[i];
        }
        friendTotals[tid] = total;
    }
}

int main() {
    int numItems, numFriends;
    int h_items[MAX_ITEMS];
    int h_purchases[MAX_FRIENDS * MAX_ITEMS];
    int h_friendTotals[MAX_FRIENDS];

    printf("Enter number of items: ");
    scanf("%d", &numItems);

    printf("Enter prices of %d items:\n", numItems);
    for (int i = 0; i < numItems; i++) {
        scanf("%d", &h_items[i]);
    }

    printf("Enter number of friends: ");
    scanf("%d", &numFriends);

    printf("Enter purchases (quantities) made by each friend for each item:\n");
    for (int i = 0; i < numFriends; i++) {
        printf("Friend %d:\n", i + 1);
        for (int j = 0; j < numItems; j++) {
            scanf("%d", &h_purchases[i * numItems + j]);
        }
    }

    int *d_items, *d_purchases, *d_friendTotals;
    cudaMalloc(&d_items, sizeof(int) * numItems);
    cudaMalloc(&d_purchases, sizeof(int) * numFriends * numItems);
    cudaMalloc(&d_friendTotals, sizeof(int) * numFriends);

    cudaMemcpy(d_items, h_items, sizeof(int) * numItems, cudaMemcpyHostToDevice);
    cudaMemcpy(d_purchases, h_purchases, sizeof(int) * numFriends * numItems, cudaMemcpyHostToDevice);

    int threadsPerBlock = 32;
    int blocksPerGrid = (numFriends + threadsPerBlock - 1) / threadsPerBlock;
    calculateTotal<<<blocksPerGrid, threadsPerBlock>>>(d_items, d_purchases, d_friendTotals, numItems);

    cudaMemcpy(h_friendTotals, d_friendTotals, sizeof(int) * numFriends, cudaMemcpyDeviceToHost);

    int grandTotal = 0;
    for (int i = 0; i < numFriends; i++) {
        printf("Friend %d total purchase: Rs. %d\n", i + 1, h_friendTotals[i]);
        grandTotal += h_friendTotals[i];
    }

    printf("Grand Total Purchase: Rs. %d\n", grandTotal);

    cudaFree(d_items);
    cudaFree(d_purchases);
    cudaFree(d_friendTotals);
    return 0;
}

/* nvcc ad1.cu -o ad1
input:
Enter number of items : 4
Enter prices of 4 items: 50 30 100 20

Enter number of friends: 3
Enter purchases(quantities) made by each friend for each item:
Friend 1:
1 2 0 4
Friend 2:
0 0 2 1
Friend 3:
3 1 1 2

*/ 


Write a program in CUDA to perform tiled 1D convolution operation on the input array N of size width using the mask array, M of size mask_width, to produce the resultant array P of size width.

#include <stdio.h>
#include <stdlib.h>

#define TILE_WIDTH 16

__global__ void tiledConvolution1D(float *N, float *M, float *P, int width, int mask_width) {
    extern __shared__ float N_s[];  
    int tid = threadIdx.x;
    int i = blockIdx.x * blockDim.x + tid;
    
    int halo = mask_width / 2;  
    
    if (i - halo >= 0 && i - halo < width)
        N_s[tid] = N[i - halo];
    else
        N_s[tid] = 0.0f;  
    
    __syncthreads();  
    
    if (i < width) {
        float Pvalue = 0.0f;
        for (int j = 0; j < mask_width; j++) {
            Pvalue += N_s[tid + j] * M[j];
        }
        P[i] = Pvalue;
    }
}

int main() {
    int width, mask_width;
    
    printf("Enter the width of the input array: ");
    scanf("%d", &width);
    printf("Enter the width of the mask array: ");
    scanf("%d", &mask_width);

    float *h_N = (float*)malloc(width * sizeof(float));
    float *h_M = (float*)malloc(mask_width * sizeof(float));
    float *h_P = (float*)malloc(width * sizeof(float));

    printf("Enter the elements of the input array:\n");
    for (int i = 0; i < width; i++)
        scanf("%f", &h_N[i]);

    printf("Enter the elements of the mask array:\n");
    for (int i = 0; i < mask_width; i++)
        scanf("%f", &h_M[i]);

    float *d_N, *d_M, *d_P;
    cudaMalloc((void**)&d_N, width * sizeof(float));
    cudaMalloc((void**)&d_M, mask_width * sizeof(float));
    cudaMalloc((void**)&d_P, width * sizeof(float));

    cudaMemcpy(d_N, h_N, width * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(d_M, h_M, mask_width * sizeof(float), cudaMemcpyHostToDevice);

    int blockSize = TILE_WIDTH;
    int gridSize = (width + blockSize - 1) / blockSize;
    int sharedMemorySize = (TILE_WIDTH + mask_width - 1) * sizeof(float);

    tiledConvolution1D<<<gridSize, blockSize, sharedMemorySize>>>(d_N, d_M, d_P, width, mask_width);

    cudaMemcpy(h_P, d_P, width * sizeof(float), cudaMemcpyDeviceToHost);

    printf("Resultant array:\n");
    for (int i = 0; i < width; i++)
        printf("%f ", h_P[i]);
    printf("\n");

    cudaFree(d_N);
    cudaFree(d_M);
    cudaFree(d_P);
    free(h_N);
    free(h_M);
    free(h_P);

    return 0;
}

/*
Enter the width of the input array: 5
Enter the width of the mask array: 3
Enter the elements of the input array:
3 6 9 12 15
Enter the elements of the mask array:
0.1 0.2 0.3 
Resultant array:
2.400000 4.200000 6.000000 7.800000 4.200000
*/


ÓUINT8_C(x) (x##u) ÔUINT16_C(x) (x##u) ÕUINT32_C(x) (x##u) ÖUINT64_C(x) __ESCAPE__(x##ull) ÙINTMAX_C(x) __ESCAPE__(x##ll) ÚUINTMAX_C(x) __ESCAPE__(x##ull)  @    6     
       C:\Keil4\ARM\RV31\INC\  stdint.h     È       C:\Keil4\ARM\RV31\INC\stdint.h ARM C/C++ Compiler, 4.1 [Build 713]          signed char short int long long unsigned char  unsigned short  unsigned int  unsigned long long Pint8_t Y% Pint16_t h& Pint32_t q' Pint64_t x( Puint8_t … + Puint16_t – , Puint32_t ¨ - Puint64_t ¸ . Pint_least8_t Y4 Pint_least16_t h5 Pint_least32_t q6 Pint_least64_t x7 Puint_least8_t … : Puint_least16_t – ; Puint_least32_t ¨ < Puint_least64_t ¸ = Pint_fast8_t qB Pint_fast16_t qC Pint_fast32_t qD Pint_fast64_t xE Puint_fast8_t ¨ H Puint_fast16_t ¨ I Puint_fast32_t ¨ J Puint_fast64_t ¸ K Pintptr_t qN Puintptr_t ¨ O Pintmax_t xR Puintmax_t ¸ S                  __CORE_CMINSTR_H__  )__NOP __nop 1__WFI __wfi 9__WFE __wfe @__SEV __sev I__ISB() __isb(0xF) Q__DSB() __dsb(0xF) Y__DMB() __dmb(0xF) c__REV __rev “__RBIT __rbit __LDREXB(ptr) ((uint8_t ) __ldrex(ptr)) §__LDREXH(ptr) ((uint16_t) __ldrex(ptr)) ±__LDREXW(ptr) ((uint32_t ) __ldrex(ptr)) ½__STREXB(value,ptr) __strex(value, ptr) É__STREXH(value,ptr) __strex(value, ptr) Õ__STREXW(value,ptr) __strex(value, ptr) à__CLREX __clrex ì__SSAT __ssat ÷__USAT __usat __CLZ __clz  L    A     
       C:\Keil4\ARM\CMSIS\Include\  core_cmInstr.h     d        C:\Keil4\ARM\CMSIS\Include\core_cmInstr.h ARM C/C++ Compiler, 4.1 [Build 713]                           __CORE_CMFUNC_H__  é__enable_fault_irq __enable_fiq ñ__disable_fault_irq __disable_fiq    L    @     
       C:\Keil4\ARM\CMSIS\Include\  core_cmFunc.h     $       C:\Keil4\ARM\CMSIS\Include\core_cmFunc.h ARM C/C++ Compiler, 4.1 [Build 713]          ;£0__get_CONTROL  $  a__result $  Y__regControl $  P <ÜA__set_CONTROL  $$  control Y__regControl $  P ;–R__get_IPSR  $  a__result $  Y__regIPSR $  P ;Ðc__get_APSR  $  a__result $  Y__regAPSR $  P ;Št__get_xPSR  $  a__result $  Y__regXPSR $  P ;Ó…__get_PSP  $  a__result $  Y__regProcessStackPointer $  P <œ–__set_PSP  $$  topOfProcStack Y__regProcessStackPointer $  P ;â§__get_MSP  $  a__result $  Y__regMainStackPointer $  P <¨¸__set_MSP  $$  topOfMainStack Y__regMainStackPointer $  P ;éÉ__get_PRIMASK  $  a__result $  Y__regPriMask $  P <£Ú__set_PRIMASK  $$  priMask Y__regPriMask $  P ;äý__get_BASEPRI  $  a__result $  Y__regBasePri $  P <ž Ž__set_BASEPRI  $$  basePri Y__regBasePri $  P ;ã Ÿ__get_FAULTMASK  $  a__result $  Y__regFaultMask $  P <£°__set_FAULTMASK  $$  faultMask Y__regFaultMask $  P             !   "   #     __CORE_CM3_H_GENERIC  E__CM3_CMSIS_VERSION_MAIN (0x02) F__CM3_CMSIS_VERSION_SUB (0x00) G__CM3_CMSIS_VERSION ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) I__CORTEX_M (0x03) M__ASM __asm N__INLINE __inline ^_`h__CORE_CM3_H_DEPENDANT  n__I volatile const p__O volatile q__IO volatile •SCB_CPUID_IMPLEMENTER_Pos 24 –SCB_CPUID_IMPLEMENTER_Msk (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos) ˜SCB_CPUID_VARIANT_Pos 20 ™SCB_CPUID_VARIANT_Msk (0xFUL << SCB_CPUID_VARIANT_Pos) ›SCB_CPUID_PARTNO_Pos 4 œSCB_CPUID_PARTNO_Msk (0xFFFUL << SCB_CPUID_PARTNO_Pos) žSCB_CPUID_REVISION_Pos 0 ŸSCB_CPUID_REVISION_Msk (0xFUL << SCB_CPUID_REVISION_Pos) ¢SCB_ICSR_NMIPENDSET_Pos 31 £SCB_ICSR_NMIPENDSET_Msk (1UL << SCB_ICSR_NMIPENDSET_Pos) ¥SCB_ICSR_PENDSVSET_Pos 28 ¦SCB_ICSR_PENDSVSET_Msk (1UL << SCB_ICSR_PENDSVSET_Pos) ¨SCB_ICSR_PENDSVCLR_Pos 27 ©SCB_ICSR_PENDSVCLR_Msk (1UL << SCB_ICSR_PENDSVCLR_Pos) «SCB_ICSR_PENDSTSET_Pos 26 ¬SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ 
SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ LPC_CANCR_BASE (LPC_APB0_BASE + 0x40000) ´ LPC_CAN1_BASE (LPC_APB0_BASE + 0x44000) µ LPC_CAN2_BASE (LPC_APB0_BASE + 0x48000) ¶ LPC_I2C1_BASE (LPC_APB0_BASE + 0x5C000) ¹ LPC_SSP0_BASE (LPC_APB1_BASE + 0x08000) º LPC_DAC_BASE (LPC_APB1_BASE + 0x0C000) » LPC_TIM2_BASE (LPC_APB1_BASE + 0x10000) ¼ LPC_TIM3_BASE (LPC_APB1_BASE + 0x14000) ½ LPC_UART2_BASE (LPC_APB1_BASE + 0x18000) ¾ LPC_UART3_BASE (LPC_APB1_BASE + 0x1C000) ¿ LPC_I2C2_BASE (LPC_APB1_BASE + 0x20000) À LPC_I2S_BASE (LPC_APB1_BASE + 0x28000) Á LPC_RIT_BASE (LPC_APB1_BASE + 0x30000) Â LPC_MCPWM_BASE (LPC_APB1_BASE + 0x38000) Ã LPC_QEI_BASE (LPC_APB1_BASE + 0x3C000) Ä LPC_SC_BASE (LPC_APB1_BASE + 0x7C000) Ç LPC_EMAC_BASE (LPC_AHB_BASE + 0x00000) È LPC_GPDMA_BASE (LPC_AHB_BASE + 0x04000) É LPC_GPDMACH0_BASE (LPC_AHB_BASE + 0x04100) Ê LPC_GPDMACH1_BASE (LPC_AHB_BASE + 0x04120) Ë LPC_GPDMACH2_BASE (LPC_AHB_BASE + 0x04140) Ì L

SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) ®SCB_ICSR_PENDSTCLR_Pos 25 ¯SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) ±SCB_ICSR_ISRPREEMPT_Pos 23 ²SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) ´SCB_ICSR_ISRPENDING_Pos 22 µSCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) ·SCB_ICSR_VECTPENDING_Pos 12 ¸SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) ºSCB_ICSR_RETTOBASE_Pos 11 »SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) ½SCB_ICSR_VECTACTIVE_Pos 0 ¾SCB_ICSR_VECTACTIVE_Msk (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos) ÁSCB_VTOR_TBLBASE_Pos 29 ÂSCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) ÄSCB_VTOR_TBLOFF_Pos 7 ÅSCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) ÈSCB_AIRCR_VECTKEY_Pos 16 ÉSCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) ËSCB_AIRCR_VECTKEYSTAT_Pos 16 ÌSCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) ÎSCB_AIRCR_ENDIANESS_Pos 15 ÏSCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) ÑSCB_AIRCR_PRIGROUP_Pos 8 ÒSCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) ÔSCB_AIRCR_SYSRESETREQ_Pos 2 ÕSCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) ×SCB_AIRCR_VECTCLRACTIVE_Pos 1 ØSCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) ÚSCB_AIRCR_VECTRESET_Pos 0 ÛSCB_AIRCR_VECTRESET_Msk (1UL << SCB_AIRCR_VECTRESET_Pos) ÞSCB_SCR_SEVONPEND_Pos 4 ßSCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) áSCB_SCR_SLEEPDEEP_Pos 2 âSCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) äSCB_SCR_SLEEPONEXIT_Pos 1 åSCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) èSCB_CCR_STKALIGN_Pos 9 éSCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) ëSCB_CCR_BFHFNMIGN_Pos 8 ìSCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) îSCB_CCR_DIV_0_TRP_Pos 4 ïSCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) ñSCB_CCR_UNALIGN_TRP_Pos 3 òSCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) ôSCB_CCR_USERSETMPEND_Pos 1 õSCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) ÷SCB_CCR_NONBASETHRDENA_Pos 0 øSCB_CCR_NONBASETHRDENA_Msk (1UL << SCB_CCR_NONBASETHRDENA_Pos) ûSCB_SHCSR_USGFAULTENA_Pos 18 üSCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) þSCB_SHCSR_BUSFAULTENA_Pos 17 ÿSCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) SCB_SHCSR_MEMFAULTENA_Pos 16 ‚SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) „SCB_SHCSR_SVCALLPENDED_Pos 15 …SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) ‡SCB_SHCSR_BUSFAULTPENDED_Pos 14 ˆSCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) ŠSCB_SHCSR_MEMFAULTPENDED_Pos 13 ‹SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) SCB_SHCSR_USGFAULTPENDED_Pos 12 ŽSCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) SCB_SHCSR_SYSTICKACT_Pos 11 ‘SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) “SCB_SHCSR_PENDSVACT_Pos 10 ”SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) –SCB_SHCSR_MONITORACT_Pos 8 —SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) ™SCB_SHCSR_SVCALLACT_Pos 7 šSCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) œSCB_SHCSR_USGFAULTACT_Pos 3 SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) ŸSCB_SHCSR_BUSFAULTACT_Pos 1  SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) ¢SCB_SHCSR_MEMFAULTACT_Pos 0 £SCB_SHCSR_MEMFAULTACT_Msk (1UL << SCB_SHCSR_MEMFAULTACT_Pos) ¦SCB_CFSR_USGFAULTSR_Pos 16 §SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) ©SCB_CFSR_BUSFAULTSR_Pos 8 ªSCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) ¬SCB_CFSR_MEMFAULTSR_Pos 0 ­SCB_CFSR_MEMFAULTSR_Msk (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos) °SCB_HFSR_DEBUGEVT_Pos 31 ±SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) ³SCB_HFSR_FORCED_Pos 30 ´SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) ¶SCB_HFSR_VECTTBL_Pos 1 ·SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) ºSCB_DFSR_EXTERNAL_Pos 4 »SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) ½SCB_DFSR_VCATCH_Pos 3 ¾SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) ÀSCB_DFSR_DWTTRAP_Pos 2 ÁSCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) ÃSCB_DFSR_BKPT_Pos 1 ÄSCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) ÆSCB_DFSR_HALTED_Pos 0 ÇSCB_DFSR_HALTED_Msk (1UL << SCB_DFSR_HALTED_Pos) ÝSysTick_CTRL_COUNTFLAG_Pos 16 ÞSysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) àSysTick_CTRL_CLKSOURCE_Pos 2 áSysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) ãSysTick_CTRL_TICKINT_Pos 1 äSysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) æSysTick_CTRL_ENABLE_Pos 0 çSysTick_CTRL_ENABLE_Msk (1UL << SysTick_CTRL_ENABLE_Pos) êSysTick_LOAD_RELOAD_Pos 0 ëSysTick_LOAD_RELOAD_Msk (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos) îSysTick_VAL_CURRENT_Pos 0 ïSysTick_VAL_CURRENT_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) òSysTick_CALIB_NOREF_Pos 31 óSysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) õSysTick_CALIB_SKEW_Pos 30 öSysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) øSysTick_CALIB_TENMS_Pos 0 ùSysTick_CALIB_TENMS_Msk (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos) «ITM_TPR_PRIVMASK_Pos 0 ¬ITM_TPR_PRIVMASK_Msk (0xFUL << ITM_TPR_PRIVMASK_Pos) ¯ITM_TCR_BUSY_Pos 23 °ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) ²ITM_TCR_ATBID_Pos 16 ³ITM_TCR_ATBID_Msk (0x7FUL << ITM_TCR_ATBID_Pos) µITM_TCR_TSPrescale_Pos 8 ¶ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) ¸ITM_TCR_SWOENA_Pos 4 ¹ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) »ITM_TCR_DWTENA_Pos 3 ¼ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) ¾ITM_TCR_SYNCENA_Pos 2 ¿ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) ÁITM_TCR_TSENA_Pos 1 ÂITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) ÄITM_TCR_ITMENA_Pos 0 ÅITM_TCR_ITMENA_Msk (1UL << ITM_TCR_ITMENA_Pos) ÈITM_IWR_ATVALIDM_Pos 0 ÉITM_IWR_ATVALIDM_Msk (1UL << ITM_IWR_ATVALIDM_Pos) ÌITM_IRR_ATREADYM_Pos 0 ÍITM_IRR_ATREADYM_Msk (1UL << ITM_IRR_ATREADYM_Pos) ÐITM_IMCR_INTEGRATION_Pos 0 ÑITM_IMCR_INTEGRATION_Msk (1UL << ITM_IMCR_INTEGRATION_Pos) ÔITM_LSR_ByteAcc_Pos 2 ÕITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) ×ITM_LSR_Access_Pos 1 ØITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) ÚITM_LSR_Present_Pos 0 ÛITM_LSR_Present_Msk (1UL << ITM_LSR_Present_Pos) ôIntType_ICTR_INTLINESNUM_Pos 0 õIntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos) øIntType_ACTLR_DISFOLD_Pos 2 ùIntType_ACTLR_DISFOLD_Msk (1UL << IntType_ACTLR_DISFOLD_Pos) ûIntType_ACTLR_DISDEFWBUF_Pos 1 üIntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos) þIntType_ACTLR_DISMCYCINT_Pos 0 ÿIntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos) MPU_TYPE_IREGION_Pos 16 žMPU_TYPE_IREGION_Msk (0xFFUL << MPU_TYPE_IREGION_Pos)  MPU_TYPE_DREGION_Pos 8 ¡MPU_TYPE_DREGION_Msk (0xFFUL << MPU_TYPE_DREGION_Pos) £MPU_TYPE_SEPARATE_Pos 0 ¤MPU_TYPE_SEPARATE_Msk (1UL << MPU_TYPE_SEPARATE_Pos) §MPU_CTRL_PRIVDEFENA_Pos 2 ¨MPU_CTRL_PRIVDEFENA_Msk (1UL << MPU_CTRL_PRIVDEFENA_Pos) ªMPU_CTRL_HFNMIENA_Pos 1 «MPU_CTRL_HFNMIENA_Msk (1UL << MPU_CTRL_HFNMIENA_Pos) ­MPU_CTRL_ENABLE_Pos 0 ®MPU_CTRL_ENABLE_Msk (1UL << MPU_CTRL_ENABLE_Pos) ±MPU_RNR_REGION_Pos 0 ²MPU_RNR_REGION_Msk (0xFFUL << MPU_RNR_REGION_Pos) µMPU_RBAR_ADDR_Pos 5 ¶MPU_RBAR_ADDR_Msk (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos) ¸MPU_RBAR_VALID_Pos 4 ¹MPU_RBAR_VALID_Msk (1UL << MPU_RBAR_VALID_Pos) »MPU_RBAR_REGION_Pos 0 ¼MPU_RBAR_REGION_Msk (0xFUL << MPU_RBAR_REGION_Pos) ¿MPU_RASR_XN_Pos 28 ÀMPU_RASR_XN_Msk (1UL << MPU_RASR_XN_Pos) ÂMPU_RASR_AP_Pos 24 ÃMPU_RASR_AP_Msk (7UL << MPU_RASR_AP_Pos) ÅMPU_RASR_TEX_Pos 19 ÆMPU_RASR_TEX_Msk (7UL << MPU_RASR_TEX_Pos) ÈMPU_RASR_S_Pos 18 ÉMPU_RASR_S_Msk (1UL << MPU_RASR_S_Pos) ËMPU_RASR_C_Pos 17 ÌMPU_RASR_C_Msk (1UL << MPU_RASR_C_Pos) ÎMPU_RASR_B_Pos 16 ÏMPU_RASR_B_Msk (1UL << MPU_RASR_B_Pos) ÑMPU_RASR_SRD_Pos 8 ÒMPU_RASR_SRD_Msk (0xFFUL << MPU_RASR_SRD_Pos) ÔMPU_RASR_SIZE_Pos 1 ÕMPU_RASR_SIZE_Msk (0x1FUL << MPU_RASR_SIZE_Pos) ×MPU_RASR_ENA_Pos 0 ØMPU_RASR_ENA_Msk (0x1UL << MPU_RASR_ENA_Pos) ïCoreDebug_DHCSR_DBGKEY_Pos 16 ðCoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) òCoreDebug_DHCSR_S_RESET_ST_Pos 25 óCoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) õCoreDebug_DHCSR_S_RETIRE_ST_Pos 24 öCoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) øCoreDebug_DHCSR_S_LOCKUP_Pos 19 ùCoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) ûCoreDebug_DHCSR_S_SLEEP_Pos 18 üCoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) þCoreDebug_DHCSR_S_HALT_Pos 17 ÿCoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) CoreDebug_DHCSR_S_REGRDY_Pos 16 ‚CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) „CoreDebug_DHCSR_C_SNAPSTALL_Pos 5 …CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) ‡CoreDebug_DHCSR_C_MASKINTS_Pos 3 ˆCoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) ŠCoreDebug_DHCSR_C_STEP_Pos 2 ‹CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) CoreDebug_DHCSR_C_HALT_Pos 1 ŽCoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) CoreDebug_DHCSR_C_DEBUGEN_Pos 0 ‘CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos) ”CoreDebug_DCRSR_REGWnR_Pos 16 •CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) —CoreDebug_DCRSR_REGSEL_Pos 0 ˜CoreDebug_DCRSR_REGSEL_Msk (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos) ›CoreDebug_DEMCR_TRCENA_Pos 24 œCoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) žCoreDebug_DEMCR_MON_REQ_Pos 19 ŸCoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) ¡CoreDebug_DEMCR_MON_STEP_Pos 18 ¢CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) ¤CoreDebug_DEMCR_MON_PEND_Pos 17 ¥CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) §CoreDebug_DEMCR_MON_EN_Pos 16 ¨CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) ªCoreDebug_DEMCR_VC_HARDERR_Pos 10 «CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) ­CoreDebug_DEMCR_VC_INTERR_Pos 9 ®CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) °CoreDebug_DEMCR_VC_BUSERR_Pos 8 ±CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) ³CoreDebug_DEMCR_VC_STATERR_Pos 7 ´CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) ¶CoreDebug_DEMCR_VC_CHKERR_Pos 6 ·CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) ¹CoreDebug_DEMCR_VC_NOCPERR_Pos 5 ºCoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) ¼CoreDebug_DEMCR_VC_MMERR_Pos 4 ½CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) ¿CoreDebug_DEMCR_VC_CORERESET_Pos 0 ÀCoreDebug_DEMCR_VC_CORERESET_Msk (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos) ÊSCS_BASE (0xE000E000UL) ËITM_BASE (0xE0000000UL) ÌCoreDebug_BASE (0xE000EDF0UL) ÍSysTick_BASE (SCS_BASE + 0x0010UL) ÎNVIC_BASE (SCS_BASE + 0x0100UL) ÏSCB_BASE (SCS_BASE + 0x0D00UL) ÑInterruptType ((InterruptType_Type *) SCS_BASE) ÒSCB ((SCB_Type *) SCB_BASE) ÓSysTick ((SysTick_Type *) SysTick_BASE) ÔNVIC ((NVIC_Type *) NVIC_BASE) ÕITM ((ITM_Type *) ITM_BASE) ÖCoreDebug ((CoreDebug_Type *) CoreDebug_BASE) ÙMPU_BASE (SCS_BASE + 0x0D90UL) ÚMPU ((MPU_Type*) MPU_BASE) ‹	ITM_RXBUFFER_EMPTY 0x5AA55AA5     Œ    ƒ     
       C:\Keil4\ARM\CMSIS\Include\ C:\Keil4\ARM\RV31\INC\  core_cm3.h   stdint.h   core_cmInstr.h   core_cmFunc.h     ø       C:\Keil4\ARM\CMSIS\Include\core_cm3.h ARM C/C++ Compiler, 4.1 [Build 713]          *Â!_reserved0 $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÔb `w $   PAPSR_Type Â ž*’!ISR $  # 	!_reserved0 $  #   S¥b æ w $   PIPSR_Type «*Æ!ISR $  # 	!_reserved0 $  # !T $  #  !IT $  # !Q $  # !V $  # !C $  # !Z $  # !N $  #   SÙb 7w $   PxPSR_Type ÆÅ*¼!nPRIV $  # !SPSEL $  # !FPCA $  # !_reserved0 $  #   SÏb ëw $   PCONTROL_Type <Ô*¦ „ò¦  ISER i# ‰$   RESERVED0 ~# £¦  ICER š#€»$   RSERVED1 °# Õ¦  ISPR Ì#€í$   RESERVED2 â# ˆ¦  ICPR ÿ#€ $   RESERVED3 # »¦  IABR 2#€Ó$  7 RESERVED4 H# ï¬ï IP e#€† $  ƒ RESERVED5 z#ð STIR ¦#€ t$  t  PNVIC_Type dð*Ï	tCPUID Õ# ICSR ¦#VTOR ¦#AIRCR ¦#SCR ¦#CCR ¦#™¬
 SHP #SHCSR ¦#$CFSR ¦#(HFSR ¦#,DFSR ¦#0MMFAR ¦#4BFAR ¦#8AFSR ¦#<ƒ	Õ PFR z#@DFR Õ#HADR Õ#L­	Õ MMFR ¤#PÂ	Õ ISAR ¹#` $  tÏPSCB_Type Ä’*Ÿ
CTRL ¦# LOAD ¦#VAL ¦#CALIB Õ# PSysTick_Type êÚSÐ
u8 ¬u16 Pu32 ¦ t  *€ ä
  PORT [# ü
$  ß RESERVED0 p#€TER ¦#€¥
$   RESERVED1 š#„TPR ¦#ÀÎ
$   RESERVED2 Ã#ÄTCR ¦#€÷
$   RESERVED3 ì#„IWR ¦#øIRR ¦#üIMCR ¦#€¹$  * RESERVED4 .#„LAR ¦#°LSR ¦#´î$   RESERVED5 c#¸PID4 Õ#ÐPID5 Õ#ÔPID6 Õ#ØPID7 Õ#ÜPID0 Õ#àPID1 Õ#äPID2 Õ#èPID3 Õ#ìCID0 Õ#ðCID1 Õ#ôCID2 Õ#øCID3 Õ#ü t4PITM_Type V¨*éRESERVED0 $  # ICTR Õ#RESERVED1 $  # PInterruptType_Type 2 ñ*ž,TYPE Õ# CTRL ¦#RNR ¦#RBAR ¦#RASR ¦#RBAR_A1 ¦#RASR_A1 ¦#RBAR_A2 ¦#RASR_A2 ¦# RBAR_A3 ¦#$RASR_A3 ¦#( PMPU_Type „ š*èDHCSR ¦# DCRSR ¦#DCRDR ¦#DEMCR ¦# PCoreDebug_Type /ìté   qITM_RxBuffer <õþNVIC_SetPriorityGrouping  $$  PriorityGroup \reg_value $  \PriorityGroupTmp $   ;¬“ NVIC_GetPriorityGrouping  $  a__result $   <Ï  NVIC_EnableIRQ  $²  IRQn  <ó­ NVIC_DisableIRQ  $²  IRQn  ;¯¼ NVIC_GetPendingIRQ  $  $²  IRQn a__result $   <ÖÉ NVIC_SetPendingIRQ  $²  IRQn  <ÿÖ NVIC_ClearPendingIRQ  $²  IRQn  ;·ã NVIC_GetActive  $  $²  IRQn a__result $   <ëô NVIC_SetPriority  $²  IRQn $$  priority  ;¥‰NVIC_GetPriority  $  $²  IRQn a__result $   ;Ú¡NVIC_EncodePriority  $  $$  PriorityGroup $$  PreemptPriority $$  SubPriority a__result $  \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   <‡¿NVIC_DecodePriority  $$  Priority $$  PriorityGroup $ pPreemptPriority $ pSubPriority \PriorityGroupTmp $  \PreemptPriorityBits $  \SubPriorityBits $   "$  <§ÑNVIC_SystemReset   ;àñSysTick_Config  $  $$  ticks a__result $   ;”—	ITM_SendChar  $  $$  ch a__result $   ;Ë­	ITM_ReceiveChar  é   a__result é   \ch é    ;÷Á	ITM_CheckChar  é   a__result é                 ü  …  ITM_RxBuffer         %   &   '   (    __SYSTEM_LPC17xx_H  !  t    h     
       C:\Keil4\ARM\INC\NXP\LPC17xx\ C:\Keil4\ARM\RV31\INC\  system_LPC17xx.h   stdint.h     €        C:\Keil4\ARM\INC\NXP\LPC17xx\system_LPC17xx.h ARM C/C++ Compiler, 4.1 [Build 713]          qSystemCoreClock $      "        „   h   SystemCoreClock          *   +   ,    __LPC17xx_H__  b__MPU_PRESENT 1 c__NVIC_PRIO_BITS 5 d__Vendor_SysTickConfig 0 gh” LPC_FLASH_BASE (0x00000000UL) • LPC_RAM_BASE (0x10000000UL) š LPC_AHBRAM0_BASE (0x2007C000UL) › LPC_AHBRAM1_BASE (0x20080000UL)  LPC_GPIO_BASE (0x2009C000UL) ž LPC_APB0_BASE (0x40000000UL) Ÿ LPC_APB1_BASE (0x40080000UL)   LPC_AHB_BASE (0x50000000UL) ¡ LPC_CM3_BASE (0xE0000000UL) ¤ LPC_WDT_BASE (LPC_APB0_BASE + 0x00000) ¥ LPC_TIM0_BASE (LPC_APB0_BASE + 0x04000) ¦ LPC_TIM1_BASE (LPC_APB0_BASE + 0x08000) § LPC_UART0_BASE (LPC_APB0_BASE + 0x0C000) ¨ LPC_UART1_BASE (LPC_APB0_BASE + 0x10000) © LPC_PWM1_BASE (LPC_APB0_BASE + 0x18000) ª LPC_I2C0_BASE (LPC_APB0_BASE + 0x1C000) « LPC_SPI_BASE (LPC_APB0_BASE + 0x20000) ¬ LPC_RTC_BASE (LPC_APB0_BASE + 0x24000) ­ LPC_GPIOINT_BASE (LPC_APB0_BASE + 0x28080) ® LPC_PINCON_BASE (LPC_APB0_BASE + 0x2C000) ¯ LPC_SSP1_BASE (LPC_APB0_BASE + 0x30000) ° LPC_ADC_BASE (LPC_APB0_BASE + 0x34000) ± LPC_CANAF_RAM_BASE (LPC_APB0_BASE + 0x38000) ² LPC_CANAF_BASE (LPC_APB0_BASE + 0x3C000) ³ LPC_CANCR_BASE (LPC_APB0_BASE + 0x40000) ´ LPC_CAN1_BASE (LPC_APB0_BASE + 0x44000) µ LPC_CAN2_BASE (LPC_APB0_BASE + 0x48000) ¶ LPC_I2C1_BASE (LPC_APB0_BASE + 0x5C000) ¹ LPC_SSP0_BASE (LPC_APB1_BASE + 0x08000) º LPC_DAC_BASE (LPC_APB1_BASE + 0x0C000) » LPC_TIM2_BASE (LPC_APB1_BASE + 0x10000) ¼ LPC_TIM3_BASE (LPC_APB1_BASE + 0x14000) ½ LPC_UART2_BASE (LPC_APB1_BASE + 0x18000) ¾ LPC_UART3_BASE (LPC_APB1_BASE + 0x1C000) ¿ LPC_I2C2_BASE (LPC_APB1_BASE + 0x20000) À LPC_I2S_BASE (LPC_APB1_BASE + 0x28000) Á LPC_RIT_BASE (LPC_APB1_BASE + 0x30000) Â LPC_MCPWM_BASE (LPC_APB1_BASE + 0x38000) Ã LPC_QEI_BASE (LPC_APB1_BASE + 0x3C000) Ä LPC_SC_BASE (LPC_APB1_BASE + 0x7C000) Ç LPC_EMAC_BASE (LPC_AHB_BASE + 0x00000) È LPC_GPDMA_BASE (LPC_AHB_BASE + 0x04000) É LPC_GPDMACH0_BASE (LPC_AHB_BASE + 0x04100) Ê LPC_GPDMACH1_BASE (LPC_AHB_BASE + 0x04120) Ë LPC_GPDMACH2_BASE (LPC_AHB_BASE + 0x04140) Ì L
